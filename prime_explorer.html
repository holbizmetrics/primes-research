<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Prime Explorer ‚Äî FRONTIER Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            min-height: 100vh;
        }

        @media (max-width: 1400px) {
            .app { grid-template-columns: 280px 1fr 260px; }
        }

        @media (max-width: 1100px) {
            .app { grid-template-columns: 260px 1fr; }
            .right-panel { display: none; }
        }

        /* MOBILE STYLES */
        @media (max-width: 768px) {
            .app { 
                grid-template-columns: 1fr; 
                grid-template-rows: 300px auto; /* Fixed height instead of vh for iOS */
                height: 100%;
                min-height: -webkit-fill-available;
            }
            .left-panel { 
                order: 2;
                max-height: none;
                overflow-y: auto;
                padding: 10px;
                -webkit-overflow-scrolling: touch;
            }
            .canvas-container { 
                order: 1;
                min-height: 300px;
                height: 300px;
                width: 100%;
            }
            canvas {
                width: 100% !important;
                height: 100% !important;
            }
            .right-panel { 
                display: none; 
            }
            h1 { font-size: 1rem; }
            .subtitle { font-size: 0.6rem; margin-bottom: 8px; }
            .section { padding: 8px; margin-bottom: 8px; }
            .section h3 { font-size: 0.8rem; padding: 6px; }
            .btn { 
                padding: 8px 12px; 
                font-size: 0.7rem;
                min-height: 44px; /* iOS recommended touch target */
            }
            select, input[type="number"], input[type="range"] {
                min-height: 44px;
                font-size: 16px; /* Prevents iOS zoom */
            }
            .control label { font-size: 0.65rem; }
            .stats-bar { 
                bottom: auto;
                top: 8px;
                left: 8px;
                font-size: 0.5rem;
                padding: 4px 6px;
                max-width: 50%;
            }
            .stat-value { font-size: 0.6rem; }
            .hover-info { display: none; } /* Too cluttered on mobile */
            .surface-info { 
                display: none; /* Hide on mobile - too cluttered */
            }
            .view-controls {
                top: 8px !important;
                right: 8px !important;
            }
            .view-controls .btn {
                padding: 4px 8px;
                min-height: 28px;
                font-size: 0.65rem;
            }
            .topology-result, .mult-result, .validation-result {
                font-size: 0.6rem;
            }
            .test-row input {
                width: 50px;
            }
        }

        @media (max-width: 480px) {
            .app {
                grid-template-rows: auto 45vh auto;
            }
            .left-panel {
                max-height: 45vh;
            }
            h1 { font-size: 0.9rem; }
            .btn-row { 
                flex-wrap: wrap; 
                gap: 4px;
            }
            .btn-row .btn {
                flex: 1 1 45%;
            }
        }

        .left-panel, .right-panel {
            background: rgba(15, 15, 25, 0.98);
            padding: 15px;
            overflow-y: auto;
            overflow-x: hidden;
            border-right: 1px solid #333;
            height: 100vh;
            max-height: 100vh;
            position: sticky;
            top: 0;
        }

        .right-panel { border-right: none; border-left: 1px solid #333; }

        /* Custom scrollbar for panels */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }
        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }
        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb {
            background: rgba(78, 205, 196, 0.4);
            border-radius: 3px;
        }
        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(78, 205, 196, 0.7);
        }

        h1 {
            font-size: 1.15rem;
            margin-bottom: 3px;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #4ecdc4, #9d4edd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle { color: #555; font-size: 0.7rem; margin-bottom: 12px; }

        .section {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.06);
        }

        .section h3 {
            font-size: 0.65rem;
            color: #4ecdc4;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .section.collapsed .section-content { display: none; }
        .section h3 { cursor: pointer; }
        .section h3::before { content: '‚ñº'; font-size: 0.5rem; transition: transform 0.2s; }
        .section.collapsed h3::before { transform: rotate(-90deg); }

        /* Help icon tooltips */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            font-size: 0.6rem;
            font-style: normal;
            background: rgba(157, 78, 221, 0.3);
            color: #9d4edd;
            border-radius: 50%;
            cursor: help;
            margin-left: auto;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .help-icon:hover {
            background: rgba(157, 78, 221, 0.6);
            color: #fff;
            transform: scale(1.1);
        }
        /* Native tooltip styling via title attribute - browsers handle this */

        .control { margin-bottom: 8px; }

        .control label {
            display: block;
            font-size: 0.65rem;
            color: #666;
            margin-bottom: 2px;
        }

        select, input[type="range"], input[type="number"] {
            width: 100%;
            background: #1a1a2e;
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'%3E%3Cpath fill='%234ecdc4' d='M2 3l3 4 3-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 25px;
        }

        select:hover, input:hover { border-color: #4ecdc4; }
        select option { background: #1a1a2e; padding: 8px; }

        .range-value { font-size: 0.7rem; color: #4ecdc4; float: right; }

        .canvas-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #080812 0%, #000 100%);
            /* iOS Safari fixes */
            -webkit-overflow-scrolling: touch;
            touch-action: none;
        }

        canvas { 
            display: block; 
            cursor: grab; 
            /* iOS Safari: prevent default touch behaviors */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas:active { cursor: grabbing; }

        .btn {
            background: rgba(78,205,196,0.15);
            border: 1px solid rgba(78,205,196,0.4);
            color: #4ecdc4;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            margin: 2px;
            transition: all 0.15s;
        }

        .btn:hover { background: rgba(78,205,196,0.3); }
        .btn.active { background: #4ecdc4; color: #000; }

        .btn-row { display: flex; flex-wrap: wrap; gap: 3px; }

        .prime-btn {
            min-width: 28px;
            padding: 4px 6px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .btn.collapse-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            border: none;
            color: #fff;
            font-weight: bold;
            width: 100%;
            padding: 8px;
            margin-top: 6px;
        }
        .btn.collapse-btn:hover { box-shadow: 0 2px 12px rgba(255,107,107,0.4); }
        .btn.collapse-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .search-row { display: flex; gap: 4px; }
        .search-row input { flex: 1; }
        .search-row button {
            padding: 6px 12px;
            background: #4ecdc4;
            border: none;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.75rem;
        }

        .checkbox-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.68rem;
            cursor: pointer;
            padding: 3px;
            border-radius: 3px;
            transition: background 0.15s;
        }

        .checkbox-item:hover { background: rgba(255,255,255,0.05); }
        .checkbox-item input { width: 12px; height: 12px; cursor: pointer; }
        .color-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

        .result-box {
            margin-top: 8px;
            padding: 8px;
            background: rgba(255,217,61,0.08);
            border: 1px solid rgba(255,217,61,0.25);
            border-radius: 5px;
            font-size: 0.75rem;
            display: none;
        }

        .result-box.visible { display: block; }
        .result-box h4 { color: #ffd93d; margin-bottom: 5px; font-size: 0.8rem; }

        .factor-chips { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 5px; }
        .factor-chip {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .surface-info {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0,0,0,0.85);
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
            max-width: 240px;
            border: 1px solid #4ecdc4;
        }

        .surface-info h4 { color: #4ecdc4; margin-bottom: 4px; font-size: 0.8rem; }
        .surface-info p { color: #999; line-height: 1.3; }

        .hover-info {
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            background: rgba(0,0,0,0.9);
            padding: 10px 12px;
            border-radius: 6px;
            display: none;
            border: 1px solid #4ecdc4;
            font-size: 0.75rem;
        }

        .hover-info.visible { display: flex; gap: 15px; align-items: center; }
        .hover-number { font-size: 1.5rem; font-weight: bold; }
        .hover-details { flex: 1; }
        .hover-color { width: 40px; height: 40px; border-radius: 6px; border: 2px solid #fff; }

        .stats-bar {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0,0,0,0.8);
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.65rem;
            display: flex;
            gap: 12px;
        }

        .stat { text-align: center; }
        .stat-value { color: #4ecdc4; font-weight: bold; font-size: 0.9rem; }
        .stat-label { color: #666; }

        .collapse-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 2px solid #ffd93d;
            border-radius: 10px;
            padding: 20px 35px;
            text-align: center;
            display: none;
            z-index: 100;
        }

        .collapse-overlay.visible { display: block; }
        .collapse-overlay h2 { font-size: 1.5rem; color: #ffd93d; margin-bottom: 6px; }
        .collapse-overlay .factors { font-size: 1.2rem; color: #fff; }
        .collapse-overlay .factors span {
            padding: 3px 10px;
            border-radius: 5px;
            margin: 0 3px;
            display: inline-block;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(157,78,221,0.1), rgba(78,205,196,0.1));
            border: 1px solid rgba(157,78,221,0.3);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.7rem;
        }

        .insight-box h4 { color: #9d4edd; margin-bottom: 5px; font-size: 0.75rem; }
        .insight-box p { line-height: 1.4; color: #aaa; }

        .test-row {
            display: flex;
            gap: 4px;
            align-items: center;
            margin-top: 6px;
        }

        .test-row input {
            width: 60px;
            text-align: center;
        }

        .test-result {
            margin-top: 6px;
            padding: 6px;
            background: rgba(78,205,196,0.1);
            border-radius: 4px;
            font-size: 0.7rem;
            display: none;
        }

        .test-result.visible { display: block; }

        /* FRONTIER EDITION - New Styles */
        .section.frontier { border-color: rgba(157,78,221,0.4); background: rgba(157,78,221,0.05); }
        .section.frontier h3 { color: #9d4edd; }

        .btn.frontier-btn { background: rgba(157,78,221,0.2); border-color: rgba(157,78,221,0.5); color: #9d4edd; }
        .btn.frontier-btn:hover { background: rgba(157,78,221,0.4); }
        .btn.frontier-btn.active { background: #9d4edd; color: #000; }

        .btn.tree-btn { background: linear-gradient(135deg, #9d4edd, #7b2cbf); border: none; color: #fff; font-weight: bold; width: 100%; padding: 8px; margin-top: 6px; }
        .btn.tree-btn:hover { box-shadow: 0 2px 12px rgba(157,78,221,0.4); }
        .btn.tree-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .mult-result { margin-top: 8px; padding: 10px; background: rgba(157,78,221,0.1); border: 1px solid rgba(157,78,221,0.3); border-radius: 6px; font-size: 0.68rem; display: none; font-family: 'Consolas', monospace; }
        .mult-result.visible { display: block; }
        .mult-result .coord { color: #4ecdc4; }
        .mult-result .error { color: #ff6b6b; font-weight: bold; }
        .mult-result .good { color: #00ff88; }
        .mult-result .label { color: #888; }

        .tree-path { margin-top: 8px; padding: 8px; background: rgba(157,78,221,0.08); border: 1px solid rgba(157,78,221,0.25); border-radius: 5px; font-size: 0.7rem; display: none; max-height: 150px; overflow-y: auto; }
        .tree-path.visible { display: block; }
        .tree-step { padding: 2px 0; border-left: 2px solid #9d4edd; padding-left: 8px; margin-left: 4px; margin-bottom: 2px; }

        .rank-indicator { display: inline-block; padding: 2px 6px; border-radius: 10px; font-size: 0.6rem; font-weight: bold; margin-left: 6px; }
        .rank-top { background: #00ff88; color: #000; }
        .rank-good { background: #ffd93d; color: #000; }
        .rank-avg { background: #4ecdc4; color: #000; }
        .rank-poor { background: #ff6b6b; color: #fff; }

        /* Topology Analysis styles */
        .topology-result { margin-top: 10px; padding: 10px; background: rgba(157,78,221,0.1); border: 1px solid rgba(157,78,221,0.3); border-radius: 6px; font-size: 0.68rem; display: none; }
        .topology-result.visible { display: block; }
        .topo-section { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(157,78,221,0.2); }
        .topo-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .topo-title { color: #9d4edd; font-weight: bold; margin-bottom: 4px; }
        .topo-bar { height: 8px; border-radius: 4px; margin: 3px 0; }
        .topo-compare { display: flex; gap: 10px; margin-top: 6px; }
        .topo-compare > div { flex: 1; text-align: center; padding: 6px; border-radius: 4px; }
        .topo-prime { background: rgba(255,107,107,0.2); border: 1px solid rgba(255,107,107,0.4); }
        .topo-composite { background: rgba(100,100,140,0.2); border: 1px solid rgba(100,100,140,0.4); }
        .topo-value { font-size: 1.1rem; font-weight: bold; }
        .topo-label { font-size: 0.6rem; color: #888; }
        .hub-high { color: #00ff88; }
        .hub-med { color: #ffd93d; }
        .hub-low { color: #4ecdc4; }

        /* Batch analysis results */
        .batch-result { margin-top: 10px; padding: 10px; background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 6px; font-size: 0.65rem; display: none; max-height: 300px; overflow-y: auto; }
        .batch-result.visible { display: block; }
        .batch-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .batch-row:last-child { border-bottom: none; }
        .batch-config { color: #4ecdc4; }
        .batch-ratio { font-weight: bold; }
        .batch-ratio.high { color: #ff6b6b; }
        .batch-ratio.neutral { color: #ffd93d; }
        .batch-ratio.low { color: #00ff88; }
        .batch-top10 { color: #888; font-size: 0.6rem; }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }
        .toast {
            background: rgba(30, 30, 50, 0.95);
            border: 1px solid rgba(78, 205, 196, 0.5);
            border-radius: 8px;
            padding: 12px 20px;
            color: #fff;
            font-size: 0.8rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toast.success { border-color: rgba(0, 255, 136, 0.6); }
        .toast.error { border-color: rgba(255, 107, 107, 0.6); }
        .toast.info { border-color: rgba(157, 78, 221, 0.6); }
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           BSD FORMULA VISUALIZATION STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .bsd-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid #4ecdc4;
        }
        .bsd-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 10px;
            text-align: center;
        }
        .bsd-equation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .bsd-left, .bsd-right {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .bsd-symbol { font-size: 0.8rem; color: #ffd93d; }
        .bsd-value { font-family: monospace; font-size: 0.65rem; color: #fff; }
        .bsd-equals { font-size: 1.2rem; color: #4ecdc4; }
        .bsd-fraction { display: flex; flex-direction: column; align-items: center; }
        .bsd-numerator { border-bottom: 1px solid #4ecdc4; padding-bottom: 3px; margin-bottom: 3px; font-size: 0.6rem; }
        .bsd-denominator { font-size: 0.6rem; }
        .bsd-term { padding: 2px 4px; border-radius: 3px; cursor: help; }
        .bsd-term.sha { background: rgba(255, 107, 107, 0.3); color: #ff6b6b; }
        .bsd-term.omega { background: rgba(78, 205, 196, 0.3); color: #4ecdc4; }
        .bsd-term.reg { background: rgba(255, 217, 61, 0.3); color: #ffd93d; }
        .bsd-term.tam { background: rgba(157, 78, 221, 0.3); color: #9d4edd; }
        .bsd-term.tors { background: rgba(255, 102, 178, 0.3); color: #ff66b2; }
        .bsd-values { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px; font-size: 0.55rem; }
        .bsd-row { display: flex; align-items: baseline; gap: 4px; }
        .bsd-label { min-width: 35px; }
        .bsd-number { font-family: monospace; color: #fff; }
        .sha-highlight { font-size: 0.85rem !important; font-weight: bold; color: #ff6b6b !important; text-shadow: 0 0 8px rgba(255, 107, 107, 0.5); }
        .bsd-note { font-size: 0.5rem; color: #888; }
        .bsd-calculation { background: rgba(0,0,0,0.2); padding: 6px; border-radius: 4px; font-family: monospace; font-size: 0.5rem; margin-bottom: 6px; text-align: center; }
        .bsd-verification { text-align: center; padding: 6px; border-radius: 4px; font-weight: bold; font-size: 0.6rem; }
        .bsd-verification.success { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .bsd-verification.warning { background: rgba(255, 217, 61, 0.2); color: #ffd93d; }

        /* Sha Structure Styles */
        .sha-container { background: linear-gradient(135deg, #2d1b4e 0%, #1a1a2e 100%); border-radius: 8px; padding: 12px; margin: 8px 0; border: 1px solid #9d4edd; }
        .sha-title { font-size: 0.7rem; font-weight: bold; color: #9d4edd; margin-bottom: 8px; }
        .sha-main { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; margin-bottom: 8px; text-align: center; }
        .sha-order { font-size: 1rem; color: #ff6b6b; font-weight: bold; }
        .sha-structure { font-size: 0.75rem; color: #4ecdc4; margin-top: 4px; }
        .sha-elements { margin-bottom: 8px; font-size: 0.55rem; }
        .sha-elements ul { margin: 4px 0 0 16px; padding: 0; }
        .sha-elements li { color: #ccc; margin: 2px 0; }
        .sha-explanation { font-size: 0.5rem; color: #aaa; line-height: 1.4; margin-bottom: 8px; }
        .sha-cassels { background: rgba(78, 205, 196, 0.1); padding: 8px; border-radius: 4px; border-left: 3px solid #4ecdc4; }
        .sha-cassels-title { font-size: 0.55rem; font-weight: bold; color: #4ecdc4; margin-bottom: 4px; }
        .sha-cassels p { font-size: 0.5rem; color: #888; margin: 0; }

        /* L-function Buildup Styles */
        .l-function-buildup { background: rgba(0,0,0,0.3); border-radius: 6px; padding: 10px; margin-top: 8px; }
        .l-title { font-size: 0.65rem; font-weight: bold; color: #ffd93d; margin-bottom: 6px; text-align: center; }
        .l-formula { font-size: 0.5rem; color: #888; text-align: center; margin-bottom: 8px; }
        .l-bars-container { position: relative; height: 50px; margin-bottom: 6px; }
        .l-bars { display: flex; align-items: flex-end; height: 40px; gap: 1px; justify-content: center; }
        .l-bar { min-width: 8px; border-radius: 2px 2px 0 0; position: relative; transition: height 0.3s; }
        .l-bar:hover { opacity: 0.8; }
        .l-prime { position: absolute; bottom: -12px; left: 50%; transform: translateX(-50%); font-size: 0.4rem; color: #666; }
        .l-baseline { position: absolute; bottom: 10px; left: 0; right: 0; height: 1px; background: #333; }
        .l-legend { display: flex; gap: 12px; justify-content: center; font-size: 0.45rem; color: #888; margin-bottom: 6px; }
        .l-legend-up { color: #ff6b6b; }
        .l-legend-down { color: #4ecdc4; }
        .l-result { text-align: center; font-size: 0.55rem; }
        .l-value { font-family: monospace; color: #00ff88; font-weight: bold; }
        .l-target { color: #888; margin-left: 8px; }

        /* Pollard p-1 Visualization Styles */
        .pollard-timeline { background: rgba(0,0,0,0.3); border-radius: 6px; padding: 10px; margin-top: 8px; }
        .pollard-title { font-size: 0.65rem; font-weight: bold; color: #ffb432; margin-bottom: 6px; }
        .pollard-step { display: flex; align-items: center; gap: 8px; padding: 4px 0; border-bottom: 1px solid rgba(255,180,50,0.1); font-size: 0.5rem; font-family: monospace; }
        .pollard-step.found { background: rgba(0,255,136,0.15); border-radius: 4px; padding: 6px; }
        .pollard-k { color: #ffb432; min-width: 30px; }
        .pollard-gcd { color: #4ecdc4; }
        .pollard-gcd.trivial { color: #555; }
        .pollard-gcd.factor { color: #00ff88; font-weight: bold; font-size: 0.6rem; }
        .smoothness-indicator { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.5rem; }
        .smoothness-indicator.smooth { background: rgba(0,255,136,0.2); color: #00ff88; }
        .smoothness-indicator.rough { background: rgba(255,107,107,0.2); color: #ff6b6b; }

        /* Animation for L-function buildup */
        @keyframes barGrow {
            from { height: 0; }
            to { height: var(--target-height); }
        }
        .l-bar.animating { animation: barGrow 0.3s ease-out forwards; }
    </style>
</head>
<body>
    <!-- Toast Notifications -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="app">
        <div class="left-panel">
            <h1>üåå Ultimate Prime Explorer</h1>
            <p class="subtitle">FRONTIER Edition ‚Äî Holger Morlok <span style="color:#666;cursor:help;" title="Keys: R=rotate, +/-=zoom, ‚Üë‚Üì‚Üê‚Üí=pan, C=center, 0=reset, W=wire, P=primes, H=help">‚å®Ô∏è</span></p>

            <!-- SURFACE GEOMETRY -->
            <div class="section">
                <h3 onclick="toggleSection(this)">üåê Surface Geometry</h3>
                <div class="section-content">
                    <div class="control">
                        <label>Surface Type</label>
                        <select id="surfaceType">
                            <optgroup label="Classic">
                                <option value="sphere">Sphere</option>
                                <option value="torus">üç© Torus</option>
                                <option value="cylinder">Cylinder</option>
                            </optgroup>
                            <optgroup label="üß¨ Helical (Test These!)">
                                <option value="singlehelix">üåÄ Single Helix</option>
                                <option value="doublehelix">üß¨ Double Helix</option>
                                <option value="triplehelix">üß¨¬≥ Triple Helix</option>
                                <option value="conicalhelix">üî∫üåÄ Conical Helix</option>
                                <option value="spiraltorus">üç©üåÄ Spiral Torus</option>
                            </optgroup>
                            <optgroup label="Platonic Solids">
                                <option value="tetrahedron">Tetrahedron</option>
                                <option value="cube">Cube</option>
                                <option value="octahedron">Octahedron</option>
                                <option value="icosahedron">Icosahedron</option>
                                <option value="dodecahedron">Dodecahedron</option>
                            </optgroup>
                            <optgroup label="Exotic">
                                <option value="mobius">M√∂bius Strip</option>
                                <option value="klein">Klein Bottle</option>
                                <option value="trefoil">Trefoil Knot</option>
                                <option value="lissajous">‚àû Lissajous</option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="control">
                        <label>Mapping</label>
                        <select id="mappingMethod">
                            <optgroup label="Classic">
                                <option value="spiral">Golden Spiral</option>
                                <option value="modular6">Modular (mod 6)</option>
                                <option value="modular30">Modular (mod 30)</option>
                                <option value="log">Logarithmic</option>
                                <option value="primeStrand">Prime/Composite Strands</option>
                            </optgroup>
                            <optgroup label="üî¨ Factor-Revealing">
                                <option value="crtTorus">CRT Residue (210√ó143)</option>
                                <option value="valuation3D">Valuation (v‚ÇÇ,v‚ÇÉ,v‚ÇÖ)</option>
                                <option value="logPhase">Log Phase (mult‚Üíadd)</option>
                                <option value="logHelix">Log Helix (best for mult!)</option>
                                <option value="spfBands">SPF Bands</option>
                                <option value="smoothness">Smoothness Clusters</option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="control">
                        <label>Mapping Mode <span style="color:#9d4edd;cursor:help;" title="Controls what 'n' means before applying the Mapping formula:&#10;&#10;‚Ä¢ Generic: n = raw integer value (Mapping dropdown applies directly)&#10;‚Ä¢ Native: Geometry-aware (BYPASSES Mapping dropdown)&#10;‚Ä¢ Prime Index: n ‚Üí œÄ(n), then Mapping applied&#10;‚Ä¢ Gap-Based: n ‚Üí gap-adjusted, then Mapping applied&#10;‚Ä¢ Residue Fingerprint: n ‚Üí CRT-encoded, then Mapping applied&#10;&#10;All modes except Native COMPOSE with the Mapping dropdown!">‚ìò</span></label>
                        <select id="mappingMode">
                            <option value="generic" selected>Generic (same for all)</option>
                            <option value="native">üéØ Native (geometry-aware)</option>
                            <option value="primeIndex">œÄ(n) Prime Index</option>
                            <option value="gapBased">Gap-Based</option>
                            <option value="residueFingerprint">Residue Fingerprint</option>
                        </select>
                    </div>
                    <div class="control">
                        <label>Max N: <span class="range-value" id="rangeValue">5000</span></label>
                        <input type="range" id="maxN" min="500" max="15000" value="5000" step="500">
                    </div>
                    <div class="control">
                        <label>Point Size: <span class="range-value" id="sizeValue">3</span></label>
                        <input type="range" id="pointSize" min="1" max="8" value="3" step="0.5">
                    </div>
                </div>
            </div>

            <!-- SPECIAL PRIME TYPES -->
            <div class="section">
                <h3 onclick="toggleSection(this)">‚≠ê Special Prime Types</h3>
                <div class="section-content">
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="showRegular" checked>
                            <span class="color-dot" style="background:#ff6b6b"></span>
                            Regular
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showTwin" checked>
                            <span class="color-dot" style="background:#ffd93d"></span>
                            Twin (p,p+2)
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showSophie" checked>
                            <span class="color-dot" style="background:#4ecdc4"></span>
                            Sophie Germain
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showMersenne" checked>
                            <span class="color-dot" style="background:#9d4edd"></span>
                            Mersenne
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showSupersingular" checked>
                            <span class="color-dot" style="background:#00ff88"></span>
                            Supersingular
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="showSafe" checked>
                            <span class="color-dot" style="background:#ff66b2"></span>
                            Safe Primes
                        </label>
                    </div>
                </div>
            </div>

            <!-- COLOR & DISPLAY -->
            <div class="section">
                <h3 onclick="toggleSection(this)">üé® Color & Display</h3>
                <div class="section-content">
                    <div class="control">
                        <label>Color Mode</label>
                        <select id="colorMode">
                            <optgroup label="Classic">
                                <option value="type">By Prime Type</option>
                                <option value="factor3">By Factors (2,3,5)</option>
                                <option value="primeIndex">Prime Index Hue</option>
                                <option value="modular">Modular Rainbow</option>
                            </optgroup>
                            <optgroup label="üî¨ Factor-Revealing">
                                <option value="smoothnessColor">Smoothness (bright=smooth)</option>
                                <option value="omegaColor">Omega (# of factors)</option>
                                <option value="spfColor">Smallest Prime Factor</option>
                                <option value="residueColor">Residue mod 210</option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="btn-row">
                        <button class="btn active" id="btnPrimes" title="Show/hide prime numbers">Primes</button>
                        <button class="btn" id="btnSemiprimes" title="Show/hide semiprimes (p√óq)">Semi</button>
                        <button class="btn" id="btnComposites" title="Show/hide other composites">Comp</button>
                        <button class="btn" id="btnWireframe" title="Toggle surface wireframe">Wire</button>
                        <button class="btn active" id="btnRotate" title="Toggle auto-rotation">Spin</button>
                    </div>
                    <div style="font-size:0.55rem;color:#666;margin-top:4px;">
                        üí° Helix Filter works on visible types above
                    </div>
                </div>
            </div>

            <!-- HELIX FILTER -->
            <div class="section">
                <h3 onclick="toggleSection(this)">üî¢ Helix Filter (Divisibility)</h3>
                <div class="section-content">
                    <div class="btn-row">
                        <button class="btn prime-btn" data-prime="2">2</button>
                        <button class="btn prime-btn" data-prime="3">3</button>
                        <button class="btn prime-btn" data-prime="5">5</button>
                        <button class="btn prime-btn" data-prime="7">7</button>
                        <button class="btn prime-btn" data-prime="11">11</button>
                        <button class="btn prime-btn" data-prime="13">13</button>
                        <button class="btn prime-btn" data-prime="17">17</button>
                        <button class="btn prime-btn" data-prime="19">19</button>
                    </div>
                    <button class="btn" id="clearFilter" style="width:100%;margin-top:6px;">Clear Filter</button>
                    <div style="font-size:0.65rem;color:#666;margin-top:4px;" id="filterStatus">No filter ‚Äî showing all</div>
                </div>
            </div>

            <!-- FACTOR FINDER & COLLAPSE -->
            <div class="section" style="border-color: rgba(255,107,107,0.3);">
                <h3 onclick="toggleSection(this)" style="color:#ff6b6b;">‚ö° Factor Finder & Collapse</h3>
                <div class="section-content">
                    <div class="search-row">
                        <input type="number" id="searchN" placeholder="Enter n...">
                        <button id="searchBtn">Find</button>
                    </div>
                    <button class="btn collapse-btn" id="collapseBtn" disabled>‚ö° COLLAPSE TO FACTORS</button>

                    <div class="result-box" id="factorResult">
                        <h4>n = <span id="resultN"></span></h4>
                        <div id="resultType"></div>
                        <div class="factor-chips" id="resultFactors"></div>
                    </div>
                </div>
            </div>

            <!-- NEW: TOPOLOGY ANALYSIS -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üî¨ Topology Analysis <span class="help-icon" title="Measures which points are 'hubs' (have many neighbors within a radius).&#10;&#10;HOW TO USE:&#10;1. Click 'Analyze' to compute neighbor counts&#10;2. 'Color by Hub' shows hub-ness visually&#10;3. Check if composites cluster as hubs&#10;&#10;WHAT IT TESTS:&#10;Do composites occupy geometrically central positions?">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Measure structural importance of positions
                    </div>
                    <div class="btn-row">
                        <button class="btn frontier-btn" id="analyzeTopologyBtn">Analyze</button>
                        <button class="btn frontier-btn" id="colorByHubBtn" title="Colors points by neighbor density:&#10;üî¥ Red = many neighbors (hub)&#10;üü° Yellow = medium&#10;üîµ Blue = few neighbors&#10;&#10;Requires clicking Analyze first!">Color by Hub</button>
                    </div>
                    <div class="btn-row" style="margin-top:4px;">
                        <button class="btn frontier-btn" id="batchAnalysisBtn">üß™ Test All Configs</button>
                    </div>
                    <div class="control" style="margin-top:8px;">
                        <label>Neighbor Radius: <span class="range-value" id="radiusValue">0.15</span></label>
                        <input type="range" id="hubRadius" min="0.05" max="0.4" value="0.15" step="0.01">
                    </div>
                    <div class="topology-result" id="topologyResult">
                        <div class="topo-section">
                            <div class="topo-title">üìä Hub Score Distribution</div>
                            <div id="hubStats"></div>
                        </div>
                        <div class="topo-section">
                            <div class="topo-title">üéØ Prime vs Composite</div>
                            <div id="primeVsComposite"></div>
                        </div>
                        <div class="topo-section">
                            <div class="topo-title">üèÜ Top Hub Positions</div>
                            <div id="topHubs"></div>
                        </div>
                    </div>
                    <div class="batch-result" id="batchResult"></div>
                </div>
            </div>

            <!-- NEW: HYPOTHESIS VALIDATION SUITE -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üß™ Hypothesis Validator <span class="help-icon" title="Rigorous statistical tests to verify if patterns are real or artifacts.&#10;&#10;HOW TO USE:&#10;1. Run 'Base Rate' to check expected vs observed&#10;2. 'Permutation' tests statistical significance&#10;3. 'N-Scaling' checks if effect persists at different sizes&#10;4. 'FULL VALIDATION' runs all tests&#10;5. 'CROSS-MODE' tests across all mapping modes&#10;&#10;WHAT IT TESTS:&#10;Is the hub effect statistically significant or random?">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Falsification engine ‚Äî test if patterns are real
                    </div>
                    <div class="control" style="margin-bottom:8px;">
                        <label style="font-size:0.65rem;">Top K Hubs to Test</label>
                        <select id="validationTopK" style="width:100%;padding:4px;background:#1a1a2e;color:#fff;border:1px solid #ff6b6b;border-radius:4px;">
                            <option value="10">Top 10</option>
                            <option value="20">Top 20</option>
                            <option value="50">Top 50</option>
                            <option value="100">Top 100 (10%)</option>
                        </select>
                    </div>
                    <div class="btn-row">
                        <button class="btn frontier-btn" id="baseRateBtn" style="border-color:#ff6b6b;">üìä Base Rate</button>
                        <button class="btn frontier-btn" id="permTestBtn" style="border-color:#ff6b6b;">üé≤ Permutation</button>
                    </div>
                    <div class="btn-row" style="margin-top:4px;">
                        <button class="btn frontier-btn" id="nScaleBtn" style="border-color:#ff6b6b;">üìà N-Scaling</button>
                        <button class="btn frontier-btn" id="radiusTestBtn" style="border-color:#ff6b6b;">‚≠ï Radius Test</button>
                    </div>
                    <div class="btn-row" style="margin-top:8px;">
                        <button class="btn frontier-btn" id="fullValidationBtn" style="border-color:#ff6b6b;background:rgba(255,107,107,0.2);width:100%;">üî¨ RUN FULL VALIDATION</button>
                    </div>
                    <div class="btn-row" style="margin-top:4px;">
                        <button class="btn frontier-btn" id="crossModeValidationBtn" style="border-color:#9d4edd;background:rgba(157,78,221,0.2);width:100%;">üîÑ CROSS-MODE VALIDATION</button>
                    </div>
                    <div class="validation-result" id="validationResult" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;font-size:0.65rem;max-height:300px;overflow-y:auto;display:none;">
                    </div>
                </div>
            </div>

            <!-- NEW: RESONANCE SPECTRUM (Eve's #5) -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üéµ Resonance Spectrum <span class="help-icon" title="Analyzes if a number N is geometrically 'close' to its factors.&#10;&#10;HOW TO USE:&#10;1. Enter a semiprime (product of 2 primes) like 1073&#10;2. Click 'Compute Spectrum' to see distance to all primes&#10;3. 'Random' picks a random semiprime to test&#10;&#10;WHAT IT SHOWS:&#10;The spectrum graph shows distance from N to each prime.&#10;If factors show special proximity, they'd appear as dips.&#10;(Spoiler: they usually don't ‚Äî geometry can't encode factors)">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Does N "resonate" with its factors? Distance spectrum to all primes.
                    </div>
                    <div class="control">
                        <label>Target N (semiprime)</label>
                        <input type="number" id="resonanceN" value="1073" min="4" style="width:100%;">
                    </div>
                    <div class="btn-row" style="margin-top:6px;">
                        <button class="btn frontier-btn" id="computeResonanceBtn" style="border-color:#9d4edd;">üìä Compute Spectrum</button>
                        <button class="btn frontier-btn" id="randomSemiprimeBtn" style="border-color:#9d4edd;">üé≤ Random</button>
                    </div>
                    <div class="resonance-result" id="resonanceResult" style="margin-top:8px;display:none;">
                        <canvas id="resonanceCanvas" width="260" height="150" style="width:100%;background:#0a0a15;border-radius:4px;"></canvas>
                        <div id="resonanceStats" style="font-size:0.6rem;margin-top:6px;"></div>
                        <button class="btn" id="copyResonanceBtn" style="margin-top:6px;font-size:0.6rem;width:100%;">üìã Copy Results</button>
                    </div>
                </div>
            </div>

            <!-- NEW: NEIGHBORHOOD LENS (Eve's #3) -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üîç Neighborhood Lens <span class="help-icon" title="Examines the geometric neighborhood around a number N.&#10;&#10;HOW TO USE:&#10;1. Enter any number N&#10;2. Set search radius (0.1 = 10% of surface)&#10;3. Click 'Analyze' to find all neighbors&#10;4. 'Highlight Factors' marks N's factors on the surface&#10;&#10;WHAT IT SHOWS:&#10;Lists all numbers within radius of N.&#10;Checks if factors appear in the neighborhood.&#10;Tests: Are factors geometrically 'nearby' their product?">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Are factors geometrically "special" in N's neighborhood?
                    </div>
                    <div class="control">
                        <label>Target N</label>
                        <input type="number" id="neighborhoodN" value="1073" min="4" style="width:100%;">
                    </div>
                    <div class="control" style="margin-top:4px;">
                        <label>Search Radius: <span id="neighborRadiusValue">0.3</span></label>
                        <input type="range" id="neighborRadius" min="0.1" max="0.8" value="0.3" step="0.05">
                    </div>
                    <div class="btn-row" style="margin-top:6px;">
                        <button class="btn frontier-btn" id="analyzeNeighborhoodBtn" style="border-color:#4ecdc4;">üîç Analyze</button>
                        <button class="btn frontier-btn" id="highlightFactorsBtn" style="border-color:#4ecdc4;">‚ú® Highlight Factors</button>
                    </div>
                    <div class="neighborhood-result" id="neighborhoodResult" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;font-size:0.6rem;display:none;">
                    </div>
                    <button class="btn" id="copyNeighborhoodBtn" style="margin-top:6px;font-size:0.6rem;width:100%;display:none;">üìã Copy Results</button>
                </div>
            </div>

            <!-- NEW: CONSTRAINT VISUALIZER (ChatGPT insight) -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üéØ Constraint Visualizer <span class="help-icon" title="Shows how extra information narrows the factorization search space.&#10;&#10;HOW TO USE:&#10;1. Enter a target N to factor&#10;2. Select a constraint type (bit length, mod info, etc.)&#10;3. Set constraint strength (0-100%)&#10;4. Click 'Visualize' to see remaining candidates&#10;5. 'Animate' shows progressive elimination&#10;&#10;WHAT IT SHOWS:&#10;Demonstrates that side-channel info (like bit lengths)&#10;reduces search space ‚Äî but geometry alone doesn't help.">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        See how extra info shrinks the search space.
                    </div>
                    <div class="control">
                        <label>Target N</label>
                        <input type="number" id="constraintN" value="1073" min="4" style="width:100%;">
                    </div>
                    <div class="control" style="margin-top:4px;">
                        <label>Constraint Type</label>
                        <select id="constraintType" style="width:100%;padding:4px;background:#1a1a2e;color:#fff;border:1px solid #ffd93d;border-radius:4px;">
                            <option value="none">No constraint (full search)</option>
                            <option value="topbits">Known top k bits of p</option>
                            <option value="sum">Known p+q ¬± error</option>
                            <option value="close">Primes are close (|p-q| < bound)</option>
                        </select>
                    </div>
                    <div class="control" style="margin-top:4px;">
                        <label>Constraint Strength: <span id="constraintStrengthValue">50%</span></label>
                        <input type="range" id="constraintStrength" min="0" max="100" value="50" step="5">
                    </div>
                    <div class="btn-row" style="margin-top:6px;">
                        <button class="btn frontier-btn" id="showConstraintBtn" style="border-color:#ffd93d;">üìê Visualize</button>
                        <button class="btn frontier-btn" id="animateConstraintBtn" style="border-color:#ffd93d;">‚ñ∂Ô∏è Animate</button>
                    </div>
                    <div class="constraint-result" id="constraintResult" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;font-size:0.6rem;display:none;">
                    </div>
                    <button class="btn" id="copyConstraintBtn" style="margin-top:6px;font-size:0.6rem;width:100%;display:none;">üìã Copy Results</button>
                </div>
            </div>

            <!-- NEW: ERROR VECTOR EXPLORER -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üìê Error Vector Explorer <span class="help-icon" title="Analyzes the 'error' when treating multiplication as addition.&#10;&#10;THE IDEA:&#10;If geometry encoded multiplication linearly, then:&#10;  Pos(p√óq) = Pos(p) + Pos(q)&#10;The ERROR is how far off this is.&#10;&#10;HOW TO USE:&#10;1. Select sample size (more = slower but better stats)&#10;2. Click 'Compute Errors' to calculate error vectors&#10;3. 'Plot' shows error distribution visually&#10;4. 'Find Correlations' checks if errors have structure&#10;&#10;WHAT IT TESTS:&#10;Is there exploitable structure in the non-linearity?&#10;Could we predict/invert errors to find factors?">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Structure in the non-linearity: Pos(p√óq) - [Pos(p) + Pos(q)]
                    </div>
                    <div class="control">
                        <label>Sample Size</label>
                        <select id="errorSampleSize" style="width:100%;padding:4px;background:#1a1a2e;color:#fff;border:1px solid #00ff88;border-radius:4px;">
                            <option value="50">50 pairs (fast)</option>
                            <option value="100">100 pairs</option>
                            <option value="200" selected>200 pairs</option>
                            <option value="500">500 pairs (thorough)</option>
                        </select>
                    </div>
                    <div class="btn-row" style="margin-top:6px;">
                        <button class="btn frontier-btn" id="computeErrorsBtn" style="border-color:#00ff88;">üìä Compute Errors</button>
                        <button class="btn frontier-btn" id="plotErrorsBtn" style="border-color:#00ff88;">üìà Plot</button>
                    </div>
                    <div class="btn-row" style="margin-top:4px;">
                        <button class="btn frontier-btn" id="errorCorrelationBtn" style="border-color:#00ff88;">üîó Find Correlations</button>
                    </div>
                    <div class="error-result" id="errorResult" style="margin-top:8px;display:none;">
                        <canvas id="errorCanvas" width="260" height="150" style="width:100%;background:#0a0a15;border-radius:4px;"></canvas>
                        <div id="errorStats" style="font-size:0.6rem;margin-top:6px;"></div>
                        <button class="btn" id="copyErrorBtn" style="margin-top:6px;font-size:0.6rem;width:100%;">üìã Copy Results</button>
                    </div>
                </div>
            </div>

            <!-- EC MODE ‚Äî Elliptic Curve Analysis -->
            <div class="section" style="border-color: rgba(80, 150, 255, 0.5); background: rgba(80, 150, 255, 0.08);">
                <h3 onclick="toggleSection(this)" style="color: #5096ff;">üî∑ Elliptic Curve Mode <span class="help-icon" title="Overlay elliptic curve data on primes.&#10;&#10;COLORS:&#10;üî¥ Bad reduction (p | conductor)&#10;üîµ Supersingular (a_p = 0)&#10;üü° Ordinary (a_p ‚â† 0)&#10;‚ö´ Unknown (no data)&#10;&#10;USE FOR:&#10;‚Ä¢ BSD conjecture visualization&#10;‚Ä¢ Sha test candidates&#10;‚Ä¢ Factor structure research">‚ìò</span></h3>
                <div class="section-content">
                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                        <input type="checkbox" id="ecModeEnabled" style="width:16px;height:16px;">
                        <label for="ecModeEnabled" style="font-size:0.7rem;font-weight:bold;">Enable EC Mode</label>
                    </div>
                    <div class="control">
                        <label>Curve</label>
                        <select id="ecCurveSelect">
                            <option value="182d1">182.d1 (Sha=9) ‚òÖ</option>
                            <option value="37a1">37a1 (rank 1)</option>
                            <option value="389a1">389a1 (rank 2)</option>
                            <option value="5077a1">5077a1 (rank 3)</option>
                            <option value="11a1">11a1 (torsion ‚Ñ§/5‚Ñ§)</option>
                            <option value="681b1">681b1 (rank 1)</option>
                        </select>
                    </div>
                    <div class="control">
                        <label>Filter</label>
                        <select id="ecFilterSelect">
                            <option value="none">All primes</option>
                            <option value="supersingular">Supersingular only</option>
                            <option value="bad">Bad reduction only</option>
                            <option value="shaTest">Sha test candidates</option>
                        </select>
                    </div>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;font-size:0.6rem;">
                        <div style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;border-radius:50%;background:#ff5050;"></span>Bad</div>
                        <div style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;border-radius:50%;background:#5096ff;"></span>SS</div>
                        <div style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;border-radius:50%;background:#ffdc50;"></span>Ord</div>
                        <div style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;border-radius:50%;background:#666;"></span>?</div>
                    </div>
                    <div class="btn-row" style="margin-top:8px;">
                        <button class="btn" id="ecStatsBtn" style="background:rgba(80,150,255,0.2);border-color:rgba(80,150,255,0.5);color:#5096ff;">üìä Stats</button>
                        <button class="btn" id="ecCompareBtn" style="background:rgba(80,150,255,0.2);border-color:rgba(80,150,255,0.5);color:#5096ff;">üîÑ Compare</button>
                    </div>
                    <div id="ecInfoPanel" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.4);border-radius:4px;font-size:0.6rem;display:none;"></div>

                    <!-- BSD Formula Analysis -->
                    <div id="bsdSection" style="margin-top:10px;display:none;">
                        <div style="font-size:0.65rem;font-weight:bold;color:#4ecdc4;margin-bottom:6px;">üìê BSD Formula Analysis</div>
                        <div id="bsdFormulaContainer"></div>
                        <div id="shaExplanationContainer"></div>
                        <div id="lFunctionContainer"></div>
                        <div class="btn-row" style="margin-top:8px;">
                            <button class="btn" id="showBSDBtn" style="background:rgba(78,205,196,0.2);border-color:#4ecdc4;color:#4ecdc4;">üìê BSD Formula</button>
                            <button class="btn" id="showShaBtn" style="background:rgba(157,78,221,0.2);border-color:#9d4edd;color:#9d4edd;">–® Structure</button>
                        </div>
                        <div class="btn-row" style="margin-top:4px;">
                            <button class="btn" id="animateLBtn" style="background:rgba(255,217,61,0.2);border-color:#ffd93d;color:#ffd93d;">‚ñ∂ Animate L</button>
                            <button class="btn" id="colorByLBtn" style="background:rgba(255,107,107,0.2);border-color:#ff6b6b;color:#ff6b6b;">üé® Color by L</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- EC FRONTIER EXPERIMENT ‚Äî Phase 3 -->
            <div class="section" style="border-color: rgba(80, 150, 255, 0.5); background: rgba(80, 150, 255, 0.08);">
                <h3 onclick="toggleSection(this)" style="color: #5096ff;">üî¨ EC FRONTIER Experiment <span class="help-icon" title="Test EC properties for factor revelation.&#10;&#10;HYPOTHESIS:&#10;Does a_n correlate with a_p + a_q?&#10;Can group structure (‚Ñ§/n‚Ñ§)* reveal p,q?&#10;&#10;Run experiment to test across curves.">‚ìò</span></h3>
                <div class="section-content">
                    <div class="test-row" style="display:flex;gap:4px;align-items:center;">
                        <input type="number" id="frontierP" placeholder="p" min="2" style="width:60px;text-align:center;">
                        <span style="color:#5096ff;font-weight:bold;">√ó</span>
                        <input type="number" id="frontierQ" placeholder="q" min="2" style="width:60px;text-align:center;">
                    </div>
                    <div class="control" style="margin-top:8px;">
                        <label>Sample Size</label>
                        <select id="frontierSampleSize">
                            <option value="50">50 pairs (fast)</option>
                            <option value="100" selected>100 pairs</option>
                            <option value="200">200 pairs (thorough)</option>
                        </select>
                    </div>
                    <div class="btn-row" style="margin-top:8px;">
                        <button class="btn" id="testSemiprimeECBtn" style="background:rgba(80,150,255,0.2);border-color:rgba(80,150,255,0.5);color:#5096ff;">Test Pair</button>
                        <button class="btn" id="groupStructureBtn" style="background:rgba(80,150,255,0.2);border-color:rgba(80,150,255,0.5);color:#5096ff;">(‚Ñ§/n‚Ñ§)*</button>
                    </div>
                    <button class="btn" id="runFrontierBtn" style="width:100%;margin-top:6px;font-weight:bold;background:rgba(80,150,255,0.2);border-color:rgba(80,150,255,0.5);color:#5096ff;">üî¨ RUN FRONTIER EXPERIMENT</button>
                    <div id="frontierResult" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.4);border-radius:4px;font-size:0.6rem;display:none;"></div>
                </div>
            </div>

            <!-- ORDER/GCD TELEMETRY ‚Äî Pollard p-1 Explorer -->
            <div class="section" style="border-color: rgba(255, 180, 50, 0.5); background: rgba(255, 180, 50, 0.08);">
                <h3 onclick="toggleSection(this)" style="color: #ffb432;">üîë Order/GCD Telemetry <span class="help-icon" title="Explore Pollard p-1 style factorization.&#10;&#10;THE IDEA:&#10;If (p-1) is smooth, then a^(k!) ‚â° 1 (mod p)&#10;so gcd(a^(k!) - 1, n) reveals p.&#10;&#10;HEURISTICS:&#10;‚Ä¢ Factorial: m = k!&#10;‚Ä¢ Primorial: m = 2¬∑3¬∑5¬∑7¬∑...&#10;‚Ä¢ LCM: m = lcm(1,2,...,k)&#10;&#10;EXPECTED:&#10;‚úì Works on smooth p-1&#10;‚úó Fails on RSA semiprimes&#10;&#10;This is exactly Pollard p-1 (1974).">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Pollard p-1: gcd(a<sup>m</sup> - 1, n) where m accumulates primes
                    </div>
                    <div class="control">
                        <label>Target n (composite)</label>
                        <input type="number" id="orderTargetN" placeholder="e.g. 1073, 8051, 15347" style="width:100%;">
                    </div>
                    <div class="control" style="margin-top:6px;">
                        <label>Heuristic for m</label>
                        <select id="orderHeuristic" style="width:100%;padding:4px;background:#1a1a2e;color:#fff;border:1px solid #ffb432;border-radius:4px;">
                            <option value="factorial">Factorial: m = k!</option>
                            <option value="primorial">Primorial: m = p‚ÇÅ¬∑p‚ÇÇ¬∑...¬∑p‚Çñ</option>
                            <option value="lcm">LCM: m = lcm(1..k)</option>
                            <option value="powersmooth">Power-smooth: lcm of prime powers</option>
                        </select>
                    </div>
                    <div class="control" style="margin-top:6px;">
                        <label>Bound k: <span id="orderBoundValue">50</span></label>
                        <input type="range" id="orderBound" min="10" max="500" value="50" step="10" style="width:100%;">
                    </div>
                    <div class="btn-row" style="margin-top:8px;">
                        <button class="btn" id="runOrderAttackBtn" style="background:rgba(255,180,50,0.2);border-color:rgba(255,180,50,0.5);color:#ffb432;font-weight:bold;">‚ñ∂ Run Attack</button>
                        <button class="btn" id="stepOrderAttackBtn" style="background:rgba(255,180,50,0.2);border-color:rgba(255,180,50,0.5);color:#ffb432;">‚è≠ Step</button>
                    </div>
                    <div class="btn-row" style="margin-top:4px;">
                        <button class="btn" id="randomSmoothBtn" style="background:rgba(0,255,136,0.15);border-color:rgba(0,255,136,0.4);color:#00ff88;">üé≤ Smooth p-1</button>
                        <button class="btn" id="randomHardBtn" style="background:rgba(255,107,107,0.15);border-color:rgba(255,107,107,0.4);color:#ff6b6b;">üé≤ RSA-style</button>
                    </div>
                    <div id="orderProgress" style="margin-top:8px;display:none;">
                        <div style="display:flex;justify-content:space-between;font-size:0.6rem;color:#888;">
                            <span>k = <span id="orderCurrentK">0</span></span>
                            <span>gcd checks: <span id="orderGcdChecks">0</span></span>
                        </div>
                        <div style="height:6px;background:#1a1a2e;border-radius:3px;margin-top:4px;overflow:hidden;">
                            <div id="orderProgressBar" style="height:100%;background:linear-gradient(90deg,#ffb432,#ff6b6b);width:0%;transition:width 0.1s;"></div>
                        </div>
                    </div>
                    <div id="orderResult" style="margin-top:8px;padding:10px;background:rgba(0,0,0,0.4);border-radius:4px;font-size:0.65rem;display:none;">
                        <div id="orderResultContent"></div>
                    </div>

                    <!-- Pollard p-1 Timeline Visualization -->
                    <div id="pollardTimeline" style="margin-top:8px;display:none;">
                        <div class="pollard-timeline">
                            <div class="pollard-title">‚è±Ô∏è Attack Timeline</div>
                            <div id="pollardTimelineContent" style="max-height:150px;overflow-y:auto;"></div>
                        </div>
                    </div>

                    <!-- Smoothness Analysis -->
                    <div id="smoothnessAnalysis" style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;display:none;">
                        <div style="font-size:0.6rem;font-weight:bold;color:#ffb432;margin-bottom:4px;">üîç Smoothness Analysis</div>
                        <div id="smoothnessContent" style="font-size:0.55rem;"></div>
                    </div>

                    <!-- Educational Comparison -->
                    <div id="smoothVsHardComparison" style="margin-top:8px;display:none;">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:0.5rem;">
                            <div style="background:rgba(0,255,136,0.1);padding:6px;border-radius:4px;border:1px solid rgba(0,255,136,0.3);">
                                <div style="color:#00ff88;font-weight:bold;">‚úì SMOOTH</div>
                                <div id="smoothExample"></div>
                            </div>
                            <div style="background:rgba(255,107,107,0.1);padding:6px;border-radius:4px;border:1px solid rgba(255,107,107,0.3);">
                                <div style="color:#ff6b6b;font-weight:bold;">‚úó RSA-STYLE</div>
                                <div id="hardExample"></div>
                            </div>
                        </div>
                    </div>

                    <div class="btn-row" style="margin-top:8px;">
                        <button class="btn" id="showTimelineBtn" style="background:rgba(255,180,50,0.15);border-color:rgba(255,180,50,0.4);color:#ffb432;">üìä Timeline</button>
                        <button class="btn" id="compareSmoothnessBtn" style="background:rgba(255,180,50,0.15);border-color:rgba(255,180,50,0.4);color:#ffb432;">‚öñÔ∏è Compare</button>
                    </div>

                    <div id="orderHistory" style="margin-top:8px;max-height:120px;overflow-y:auto;font-size:0.6rem;display:none;">
                        <div style="color:#888;margin-bottom:4px;">History:</div>
                        <div id="orderHistoryContent"></div>
                    </div>
                </div>
            </div>

            <!-- NEW: MULTIPLICATION LAB -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üß™ Multiplication Lab <span class="help-icon" title="Interactive lab to test multiplication additivity hypothesis.&#10;&#10;THE QUESTION:&#10;Does Œ¶(p√óq) ‚âà Œ¶(p) + Œ¶(q) for some feature Œ¶?&#10;If yes, factoring would reduce to subtraction!&#10;&#10;HOW TO USE:&#10;1. Select a Feature Mode (position, angle, log, etc.)&#10;2. Enter two primes p and q&#10;3. Click 'Test Pair' to compare Œ¶(p√óq) vs Œ¶(p)+Œ¶(q)&#10;4. 'Batch Test' runs many pairs for statistics&#10;5. 'Random Pair' picks random primes to test&#10;&#10;WHAT TO LOOK FOR:&#10;Low error ratio (< 0.1) would mean near-additive!&#10;(Spoiler: position-based features always have large errors)">‚ìò</span></h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Test: Œ¶(p√óq) vs Œ¶(p) + Œ¶(q)
                    </div>

                    <!-- NEW: Feature Mode Selector -->
                    <div class="control" style="margin-bottom:8px;">
                        <label style="font-size:0.65rem;">Feature Mode</label>
                        <select id="featureMode" style="width:100%;padding:4px;background:#1a1a2e;color:#fff;border:1px solid #4ecdc4;border-radius:4px;">
                            <option value="position">Position (Pos xyz)</option>
                            <option value="log">Log (exact for mult!)</option>
                            <option value="valuation">Valuation v‚ÇÇ,v‚ÇÉ,v‚ÇÖ (exact!)</option>
                            <option value="mixed">Mixed (log+val+res)</option>
                            <option value="residue">Residue (mod 7,11,13)</option>
                            <option value="residueZero">Residue Zero-Dist (factor detect!)</option>
                        </select>
                    </div>

                    <div class="test-row">
                        <input type="number" id="multP" placeholder="p" min="2">
                        <span style="color:#9d4edd;font-weight:bold;">√ó</span>
                        <input type="number" id="multQ" placeholder="q" min="2">
                        <button class="btn frontier-btn" id="multBtn">Multiply</button>
                    </div>
                    <div class="btn-row" style="margin-top:6px;">
                        <button class="btn frontier-btn" id="showVectorBtn">Show Vector</button>
                        <button class="btn frontier-btn" id="findMinErrorBtn">Find Min Error</button>
                    </div>
                    <div class="mult-result" id="multResult">
                        <div><span class="label" id="labelP">Œ¶(p):</span> <span class="coord" id="posP"></span></div>
                        <div><span class="label" id="labelQ">Œ¶(q):</span> <span class="coord" id="posQ"></span></div>
                        <div><span class="label" id="labelSum">Œ¶(p)+Œ¶(q):</span> <span class="coord" id="posSum"></span></div>
                        <div><span class="label" id="labelPQ">Œ¶(p√óq):</span> <span class="coord" id="posPQ"></span></div>
                        <div style="margin-top:6px;padding-top:6px;border-top:1px solid rgba(157,78,221,0.3);">
                            <span class="label">Error Œî:</span> <span id="errorDelta"></span>
                            <span id="errorRank"></span>
                        </div>
                    </div>
                    <div class="mult-result" id="minErrorResult"></div>

                    <!-- NEW: Feature explanation -->
                    <div id="featureExplain" style="font-size:0.6rem;color:#666;margin-top:8px;padding:6px;background:rgba(0,0,0,0.2);border-radius:4px;">
                        <strong>Position:</strong> Tests if geometric position is additive under multiplication.
                    </div>
                </div>
            </div>

            <!-- NEW: FACTOR TREE DESCENT -->
            <div class="section frontier">
                <h3 onclick="toggleSection(this)">üå≥ Factor Tree Descent</h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Animated path from n ‚Üí prime factors
                    </div>
                    <div class="search-row">
                        <input type="number" id="treeN" placeholder="Enter n..." min="4">
                        <button class="btn frontier-btn" id="treeBtn">Build Tree</button>
                    </div>
                    <button class="btn tree-btn" id="animateTreeBtn" disabled>üå≥ ANIMATE DESCENT</button>
                    <div class="tree-path" id="treePath"></div>
                </div>
            </div>

            <!-- ADDITIVE TEST (Legacy) -->
            <div class="section collapsed">
                <h3 onclick="toggleSection(this)">üî¨ Additive Test (Legacy)</h3>
                <div class="section-content">
                    <div style="font-size:0.65rem;color:#888;margin-bottom:6px;">
                        Test if Position(p√óq) ‚âà Position(p) + Position(q)
                    </div>
                    <div class="test-row">
                        <input type="number" id="testP" placeholder="p">
                        <span>√ó</span>
                        <input type="number" id="testQ" placeholder="q">
                        <button class="btn" id="testBtn">Test</button>
                    </div>
                    <div class="test-result" id="testResult"></div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>

            <div class="surface-info" id="surfaceInfo">
                <h4>Sphere</h4>
                <p>Golden spiral mapping. Classic visualization of prime distribution.</p>
            </div>

            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="statTotal">0</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="statPrimes">0</div>
                    <div class="stat-label">Primes</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="statSpecial">0</div>
                    <div class="stat-label">Special</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="zoomLevel">1.0x</div>
                    <div class="stat-label">Zoom üîç</div>
                </div>
            </div>

            <!-- NEW: View Controls Overlay -->
            <div class="view-controls" style="position:absolute;top:12px;right:200px;display:flex;gap:4px;flex-wrap:wrap;max-width:200px;">
                <button class="btn" id="zoomInBtn" title="Zoom In (or scroll)">‚ûï</button>
                <button class="btn" id="zoomOutBtn" title="Zoom Out (or scroll)">‚ûñ</button>
                <button class="btn" id="centerViewBtn" title="Center View">‚äô</button>
                <button class="btn" id="resetViewBtn" title="Reset All">üîÑ</button>
                <button class="btn active" id="spinToggleBtn" title="Toggle Spin">üîÅ</button>
                <button class="btn" id="panUpBtn" title="Pan Up">‚¨ÜÔ∏è</button>
                <button class="btn" id="panDownBtn" title="Pan Down">‚¨áÔ∏è</button>
                <button class="btn" id="panLeftBtn" title="Pan Left">‚¨ÖÔ∏è</button>
                <button class="btn" id="panRightBtn" title="Pan Right">‚û°Ô∏è</button>
                <button class="btn" id="viewTopBtn" title="View from Above (North Pole)">üîù</button>
                <button class="btn" id="viewBottomBtn" title="View from Below (South Pole)">üîª</button>
                <button class="btn" id="viewSideBtn" title="View from Side (Equator)">‚óÄÔ∏è</button>
            </div>

            <div class="hover-info" id="hoverInfo">
                <div class="hover-number" id="hoverN">‚Äî</div>
                <div class="hover-details">
                    <div id="hoverType">‚Äî</div>
                    <div id="hoverFactors">‚Äî</div>
                    <div id="hoverSpecial">‚Äî</div>
                </div>
                <div class="hover-color" id="hoverColor"></div>
            </div>

            <div class="collapse-overlay" id="collapseOverlay">
                <h2 id="overlayTitle">COLLAPSED!</h2>
                <div class="factors" id="overlayFactors"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="section">
                <h3>üìä Prime Type Legend</h3>
                <div class="section-content" style="font-size:0.7rem;">
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#ff6b6b"></span> Regular primes
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#ffd93d"></span> Twin (p and p+2 both prime)
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#4ecdc4"></span> Sophie Germain (2p+1 prime)
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#9d4edd"></span> Mersenne (2·µñ-1)
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#00ff88"></span> Supersingular
                    </div>
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span class="color-dot" style="background:#ff66b2"></span> Safe (p = 2q+1)
                    </div>
                </div>
            </div>

            <div class="insight-box">
                <h4>üß¨ Double Helix</h4>
                <p>DNA-like structure separates primes and composites onto opposite strands. Look for "base pair" relationships!</p>
            </div>

            <div class="insight-box">
                <h4>‚öΩ Soccer Ball Pattern</h4>
                <p>The cellular structure persists across ALL color modes ‚Äî it's in the geometry (golden spiral + icosahedron), not the factor encoding!</p>
            </div>

            <div class="insight-box">
                <h4>üß™ Multiplication Lab</h4>
                <p>Tests the additive conjecture: if factorization were "linear", Pos(p√óq) would equal Pos(p)+Pos(q). The error vector shows the non-linearity!</p>
            </div>

            <div class="insight-box">
                <h4>üå≥ Factor Tree</h4>
                <p>Every composite traces a unique path down to primes. Do similar numbers follow similar paths? The descent reveals hidden structure.</p>
            </div>

            <div class="insight-box">
                <h4>üî¨ Supersingular Primes</h4>
                <p>Only 15 exist: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 47, 59, 71. They're connected to elliptic curves and the Monster group!</p>
            </div>
        </div>
    </div>

    <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: PrimeMath ‚Äî Static utility class for prime-related calculations
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class PrimeMath {
        static PHI = (1 + Math.sqrt(5)) / 2;
        static GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
        static SUPERSINGULAR = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 47, 59, 71]);
        static MERSENNE = new Set([3, 7, 31, 127, 8191]);

        static isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) if (n % i === 0) return false;
            return true;
        }

        static factorize(n) {
            const factors = [];
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                while (temp % p === 0) { factors.push(p); temp /= p; }
            }
            if (temp > 1) factors.push(temp);
            return factors;
        }

        static isSemiprime(n) { return this.factorize(n).length === 2; }
        static isTwin(p) { return this.isPrime(p) && (this.isPrime(p - 2) || this.isPrime(p + 2)); }
        static isSophieGermain(p) { return this.isPrime(p) && this.isPrime(2 * p + 1); }
        static isSafe(p) { return this.isPrime(p) && p > 2 && this.isPrime((p - 1) / 2); }
        static isMersenne(p) { return this.MERSENNE.has(p); }
        static isSupersingular(p) { return this.SUPERSINGULAR.has(p); }
        static primeExponent(n, p) { let e = 0; while (n % p === 0) { e++; n /= p; } return e; }

        static getPrimeType(n) {
            if (!this.isPrime(n)) return null;
            if (this.isSupersingular(n)) return 'supersingular';
            if (this.isMersenne(n)) return 'mersenne';
            if (this.isSophieGermain(n)) return 'sophie';
            if (this.isSafe(n)) return 'safe';
            if (this.isTwin(n)) return 'twin';
            return 'regular';
        }

        // NEW: Get smallest factor
        static smallestFactor(n) {
            if (n < 2) return n;
            if (n % 2 === 0) return 2;
            for (let i = 3; i * i <= n; i += 2) if (n % i === 0) return i;
            return n;
        }

        // NEW: Get descent steps for factor tree
        static getDescentSteps(n) {
            const steps = [{ n, factors: null, isStart: true }];
            let current = n;

            while (!this.isPrime(current) && current > 1) {
                const sf = this.smallestFactor(current);
                const remainder = current / sf;
                steps.push({ 
                    n: current, 
                    factors: [sf, remainder],
                    smallest: sf,
                    remainder: remainder
                });
                current = remainder;
            }

            return steps;
        }

        // NEW: p-adic valuation v_p(n) = exponent of p in factorization of n
        static valuation(n, p) {
            if (n === 0) return Infinity;
            let v = 0;
            while (n % p === 0) { v++; n /= p; }
            return v;
        }

        // NEW: Smoothness score - sum of valuations for small primes
        static smoothness(n, B = 7) {
            const smallPrimes = [2, 3, 5, 7, 11, 13].filter(p => p <= B);
            let score = 0;
            for (const p of smallPrimes) {
                score += this.valuation(n, p);
            }
            return score;
        }

        // NEW: Omega function - number of prime factors with multiplicity
        static omega(n) {
            if (n < 2) return 0;
            let count = 0;
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                while (temp % p === 0) { count++; temp /= p; }
            }
            if (temp > 1) count++; // remaining prime factor
            return count;
        }

        // NEW: Little omega - number of distinct prime factors
        static littleOmega(n) {
            if (n < 2) return 0;
            let count = 0;
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                if (temp % p === 0) {
                    count++;
                    while (temp % p === 0) temp /= p;
                }
            }
            if (temp > 1) count++;
            return count;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: Point ‚Äî Represents a single integer with position and color
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class Point {
        constructor(n) {
            this.n = n;
            this.x = 0; this.y = 0; this.z = 0;
            this.color = { r: 128, g: 128, b: 128 };
            this.isPrime = PrimeMath.isPrime(n);
            this.isSemiprime = PrimeMath.isSemiprime(n);
            this.primeType = PrimeMath.getPrimeType(n);
            this.factors = PrimeMath.factorize(n);
        }

        setPosition(x, y, z) { this.x = x; this.y = y; this.z = z; }
        setColor(color) { this.color = color; }

        get hex() {
            return '#' + [this.color.r, this.color.g, this.color.b]
                .map(x => Math.max(0, Math.min(255, Math.floor(x))).toString(16).padStart(2, '0')).join('');
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SURFACE CLASSES ‚Äî Each surface type is its own class
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class Surface {
        constructor(name, desc) { this.name = name; this.description = desc; }
        mapPoint(t, theta, phi, isPrime) { return { x: 0, y: 0, z: 0 }; }
        getWireframe() { return []; }
    }

    class Sphere extends Surface {
        constructor() { super('Sphere', 'Golden spiral mapping on S¬≤. Classic prime distribution.'); }
        mapPoint(t, theta, phi) {
            return { 
                x: Math.sin(phi) * Math.cos(theta), 
                y: Math.sin(phi) * Math.sin(theta), 
                z: Math.cos(phi) 
            };
        }
        getWireframe() {
            const lines = [];
            for (let lat = -60; lat <= 60; lat += 30) {
                const pts = [], p = (90 - lat) * Math.PI / 180;
                for (let lon = 0; lon <= 360; lon += 10) {
                    const t = lon * Math.PI / 180;
                    pts.push({ x: Math.sin(p)*Math.cos(t), y: Math.sin(p)*Math.sin(t), z: Math.cos(p) });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    class DoubleHelix extends Surface {
        constructor() { 
            super('üß¨ Double Helix', 'DNA structure ‚Äî primes and composites on opposite strands BY DESIGN (not discovered).'); 
            this.radius = 0.4; 
        }
        mapPoint(t, theta, phi, isPrime) {
            const angle = t * Math.PI * 8 + (isPrime ? 0 : Math.PI);
            return { 
                x: this.radius * Math.cos(angle), 
                y: this.radius * Math.sin(angle), 
                z: (t - 0.5) * 2 
            };
        }
        getWireframe() {
            const lines = [];
            for (let s = 0; s < 2; s++) {
                const pts = [];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100, angle = t * Math.PI * 8 + s * Math.PI;
                    pts.push({ x: this.radius * Math.cos(angle), y: this.radius * Math.sin(angle), z: (t - 0.5) * 2 });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    // NEW: Single Helix ‚Äî to test if "double" matters
    class SingleHelix extends Surface {
        constructor() { 
            super('üåÄ Single Helix', 'One spiral strand ‚Äî is "double" required for the effect?'); 
            this.radius = 0.4; 
        }
        mapPoint(t, theta, phi, isPrime) {
            // Single helix - all points on ONE strand
            const angle = t * Math.PI * 8;
            return { 
                x: this.radius * Math.cos(angle), 
                y: this.radius * Math.sin(angle), 
                z: (t - 0.5) * 2 
            };
        }
        getWireframe() {
            const pts = [];
            for (let i = 0; i <= 100; i++) {
                const t = i / 100, angle = t * Math.PI * 8;
                pts.push({ x: this.radius * Math.cos(angle), y: this.radius * Math.sin(angle), z: (t - 0.5) * 2 });
            }
            return [pts];
        }
    }

    // NEW: Triple Helix ‚Äî more strands = stronger effect?
    class TripleHelix extends Surface {
        constructor() { 
            super('üß¨¬≥ Triple Helix', 'Three strands ‚Äî primes on one, composites on other two.'); 
            this.radius = 0.4; 
        }
        mapPoint(t, theta, phi, isPrime) {
            // Primes on strand 0, composites alternate strands 1 and 2
            const strand = isPrime ? 0 : ((Math.round(t * 15000) % 2) + 1);
            const angle = t * Math.PI * 8 + strand * (2 * Math.PI / 3);
            return { 
                x: this.radius * Math.cos(angle), 
                y: this.radius * Math.sin(angle), 
                z: (t - 0.5) * 2 
            };
        }
        getWireframe() {
            const lines = [];
            for (let s = 0; s < 3; s++) {
                const pts = [];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100, angle = t * Math.PI * 8 + s * (2 * Math.PI / 3);
                    pts.push({ x: this.radius * Math.cos(angle), y: this.radius * Math.sin(angle), z: (t - 0.5) * 2 });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    // NEW: Conical Helix ‚Äî helix on a cone
    class ConicalHelix extends Surface {
        constructor() { 
            super('üî∫üåÄ Conical Helix', 'Spiral on a cone ‚Äî radius varies with height.'); 
        }
        mapPoint(t, theta, phi, isPrime) {
            const angle = t * Math.PI * 8 + (isPrime ? 0 : Math.PI);
            const radius = 0.1 + t * 0.5; // Expands as we go up
            return { 
                x: radius * Math.cos(angle), 
                y: radius * Math.sin(angle), 
                z: (t - 0.5) * 2 
            };
        }
        getWireframe() {
            const lines = [];
            for (let s = 0; s < 2; s++) {
                const pts = [];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100, angle = t * Math.PI * 8 + s * Math.PI;
                    const radius = 0.1 + t * 0.5;
                    pts.push({ x: radius * Math.cos(angle), y: radius * Math.sin(angle), z: (t - 0.5) * 2 });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    // NEW: Lissajous Curve ‚Äî interesting 3D figure-8 patterns
    class Lissajous extends Surface {
        constructor() { 
            super('‚àû Lissajous', '3D figure-8 curves ‚Äî harmonic ratios.'); 
        }
        mapPoint(t, theta, phi, isPrime) {
            const tt = t * 2 * Math.PI;
            const offset = isPrime ? 0 : 0.1;
            return { 
                x: Math.sin(3 * tt + offset) * 0.8, 
                y: Math.sin(4 * tt) * 0.8, 
                z: Math.sin(5 * tt) * 0.8 
            };
        }
        getWireframe() {
            const pts = [];
            for (let i = 0; i <= 200; i++) {
                const t = i / 200, tt = t * 2 * Math.PI;
                pts.push({ x: Math.sin(3 * tt) * 0.8, y: Math.sin(4 * tt) * 0.8, z: Math.sin(5 * tt) * 0.8 });
            }
            return [pts];
        }
    }

    // NEW: Spiral Torus ‚Äî helix wrapped around a torus
    class SpiralTorus extends Surface {
        constructor() { 
            super('üç©üåÄ Spiral Torus', 'Helix wrapped around donut ‚Äî double periodicity.'); 
            this.R = 0.7; this.r = 0.3;
        }
        mapPoint(t, theta, phi, isPrime) {
            // Spiral path around torus
            const u = t * 8 * Math.PI; // Big loop
            const v = t * 24 * Math.PI + (isPrime ? 0 : Math.PI); // Small loops
            return { 
                x: (this.R + this.r * Math.cos(v)) * Math.cos(u), 
                y: (this.R + this.r * Math.cos(v)) * Math.sin(u), 
                z: this.r * Math.sin(v) 
            };
        }
        getWireframe() {
            const lines = [];
            for (let s = 0; s < 2; s++) {
                const pts = [];
                for (let i = 0; i <= 200; i++) {
                    const t = i / 200;
                    const u = t * 8 * Math.PI;
                    const v = t * 24 * Math.PI + s * Math.PI;
                    pts.push({ 
                        x: (this.R + this.r * Math.cos(v)) * Math.cos(u), 
                        y: (this.R + this.r * Math.cos(v)) * Math.sin(u), 
                        z: this.r * Math.sin(v) 
                    });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    class Torus extends Surface {
        constructor() { 
            super('üç© Torus', 'Two fundamental loops. Do twin primes follow tracks?'); 
            this.R = 1; this.r = 0.4; 
        }
        mapPoint(t, theta, phi) {
            const u = theta * 2, v = phi * 2;
            return { 
                x: (this.R + this.r * Math.cos(v)) * Math.cos(u), 
                y: (this.R + this.r * Math.cos(v)) * Math.sin(u), 
                z: this.r * Math.sin(v) 
            };
        }
        getWireframe() {
            const lines = [];
            for (let i = 0; i < 12; i++) {
                const pts = [], u = i * Math.PI / 6;
                for (let j = 0; j <= 36; j++) {
                    const v = j * Math.PI / 18;
                    pts.push({ 
                        x: (this.R + this.r * Math.cos(v)) * Math.cos(u), 
                        y: (this.R + this.r * Math.cos(v)) * Math.sin(u), 
                        z: this.r * Math.sin(v) 
                    });
                }
                lines.push(pts);
            }
            return lines;
        }
    }

    class Cylinder extends Surface {
        constructor() { super('Cylinder', 'Height = magnitude, angle = spiral.'); }
        mapPoint(t, theta) { 
            return { x: Math.cos(theta * 3), y: Math.sin(theta * 3), z: (t - 0.5) * 2 }; 
        }
        getWireframe() {
            const lines = [];
            // Circles at different heights
            for (let h = -1; h <= 1; h += 0.5) {
                const pts = [];
                for (let a = 0; a <= 360; a += 15) {
                    const rad = a * Math.PI / 180;
                    pts.push({ x: Math.cos(rad), y: Math.sin(rad), z: h });
                }
                lines.push(pts);
            }
            // Vertical lines
            for (let a = 0; a < 360; a += 45) {
                const rad = a * Math.PI / 180;
                lines.push([
                    { x: Math.cos(rad), y: Math.sin(rad), z: -1 },
                    { x: Math.cos(rad), y: Math.sin(rad), z: 1 }
                ]);
            }
            return lines;
        }
    }

    class Mobius extends Surface {
        constructor() { super('M√∂bius Strip', 'Non-orientable! One side, one edge.'); }
        mapPoint(t, theta) {
            const u = t * 2 * Math.PI, v = (theta / Math.PI - 1) * 0.4, hu = u / 2;
            return { 
                x: (1 + v * Math.cos(hu)) * Math.cos(u), 
                y: (1 + v * Math.cos(hu)) * Math.sin(u), 
                z: v * Math.sin(hu) 
            };
        }
        getWireframe() {
            const lines = [];
            // Center line
            const center = [];
            for (let i = 0; i <= 50; i++) {
                const u = (i / 50) * 2 * Math.PI;
                center.push({ x: Math.cos(u), y: Math.sin(u), z: 0 });
            }
            lines.push(center);
            // Edge lines
            for (let side of [-0.4, 0.4]) {
                const edge = [];
                for (let i = 0; i <= 100; i++) {
                    const u = (i / 100) * 2 * Math.PI, hu = u / 2;
                    edge.push({
                        x: (1 + side * Math.cos(hu)) * Math.cos(u),
                        y: (1 + side * Math.cos(hu)) * Math.sin(u),
                        z: side * Math.sin(hu)
                    });
                }
                lines.push(edge);
            }
            return lines;
        }
    }

    class Klein extends Surface {
        constructor() { super('Klein Bottle', 'Non-orientable surface that passes through itself.'); }
        mapPoint(t, theta) {
            const u = t * 2 * Math.PI, v = theta;
            const r = 4 * (1 - Math.cos(u) / 2);
            let x, y, z;
            if (u < Math.PI) {
                x = 6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(u) * Math.cos(v);
                y = 16 * Math.sin(u) + r * Math.sin(u) * Math.cos(v);
            } else {
                x = 6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(v + Math.PI);
                y = 16 * Math.sin(u);
            }
            z = r * Math.sin(v);
            return { x: x * 0.05, y: y * 0.05, z: z * 0.1 };
        }
        getWireframe() {
            const lines = [];
            // Longitudinal lines
            for (let vv = 0; vv < Math.PI * 2; vv += Math.PI / 4) {
                const line = [];
                for (let i = 0; i <= 50; i++) {
                    const pt = this.mapPoint(i / 50, vv);
                    line.push(pt);
                }
                lines.push(line);
            }
            return lines;
        }
    }

    class Trefoil extends Surface {
        constructor() { super('Trefoil Knot', 'Simplest non-trivial knot.'); this.scale = 0.5; }
        mapPoint(t) {
            const tt = t * 2 * Math.PI;
            return { 
                x: this.scale * (Math.sin(tt) + 2 * Math.sin(2 * tt)), 
                y: this.scale * (Math.cos(tt) - 2 * Math.cos(2 * tt)), 
                z: this.scale * (-Math.sin(3 * tt)) 
            };
        }
        getWireframe() {
            const line = [];
            for (let i = 0; i <= 100; i++) {
                line.push(this.mapPoint(i / 100));
            }
            return [line];
        }
    }

    class Polyhedron extends Surface {
        constructor(type) {
            const info = { 
                tetrahedron: 'Simplest Platonic solid.', 
                cube: '6 faces, classic.', 
                octahedron: 'Dual to cube.',
                icosahedron: 'Soccer ball! 20 faces.', 
                dodecahedron: '12 pentagons.' 
            };
            super(type.charAt(0).toUpperCase() + type.slice(1), info[type] || '');
            this.type = type;
            this.vertices = this._getVertices();
        }

        _getVertices() {
            const p = PrimeMath.PHI;
            switch(this.type) {
                case 'tetrahedron': 
                    return [[1,1,1],[1,-1,-1],[-1,1,-1],[-1,-1,1]]
                        .map(v => ({x:v[0]/1.7, y:v[1]/1.7, z:v[2]/1.7}));
                case 'cube': { 
                    const c = []; 
                    for(let x of [-1,1]) for(let y of [-1,1]) for(let z of [-1,1]) 
                        c.push({x:x/1.7, y:y/1.7, z:z/1.7}); 
                    return c; 
                }
                case 'octahedron': 
                    return [{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1}];
                case 'icosahedron': { 
                    const v = [], m = Math.sqrt(1 + 1/(p*p)); 
                    for(let s1 of [-1,1]) for(let s2 of [-1,1]) {
                        v.push({x:0, y:s1/p, z:s2});
                        v.push({x:s1/p, y:s2, z:0});
                        v.push({x:s2, y:0, z:s1/p});
                    } 
                    return v.map(vv => ({x:vv.x/m, y:vv.y/m, z:vv.z/m})); 
                }
                case 'dodecahedron': { 
                    const v = []; 
                    for(let x of [-1,1]) for(let y of [-1,1]) for(let z of [-1,1]) 
                        v.push({x, y, z}); 
                    for(let s1 of [-1,1]) for(let s2 of [-1,1]) {
                        v.push({x:0, y:s1*p, z:s2/p});
                        v.push({x:s1/p, y:0, z:s2*p});
                        v.push({x:s1*p, y:s2/p, z:0});
                    } 
                    return v.map(vv => ({x:vv.x/p, y:vv.y/p, z:vv.z/p})); 
                }
                default: return [];
            }
        }

        mapPoint(t, theta, phi) {
            let x = Math.sin(phi) * Math.cos(theta);
            let y = Math.sin(phi) * Math.sin(theta);
            let z = Math.cos(phi);

            if (this.vertices.length > 0) {
                let nearest = this.vertices[0], minD = Infinity;
                for (const v of this.vertices) { 
                    const d = Math.hypot(x-v.x, y-v.y, z-v.z); 
                    if (d < minD) { minD = d; nearest = v; } 
                }
                const b = 0.35; 
                x = x*(1-b) + nearest.x*b; 
                y = y*(1-b) + nearest.y*b; 
                z = z*(1-b) + nearest.z*b;
            }
            return { x, y, z };
        }

        // NEW: Wireframe for polyhedra - draw edges between vertices
        getWireframe() {
            const edges = this._getEdges();
            return edges.map(([i, j]) => [this.vertices[i], this.vertices[j]]);
        }

        _getEdges() {
            switch(this.type) {
                case 'tetrahedron':
                    return [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]];
                case 'cube':
                    // 8 vertices: 0-3 bottom face, 4-7 top face
                    return [
                        [0,1],[1,3],[3,2],[2,0], // bottom
                        [4,5],[5,7],[7,6],[6,4], // top
                        [0,4],[1,5],[2,6],[3,7]  // sides
                    ];
                case 'octahedron':
                    // 6 vertices: ¬±x, ¬±y, ¬±z
                    return [
                        [0,2],[0,3],[0,4],[0,5], // +x connections
                        [1,2],[1,3],[1,4],[1,5], // -x connections
                        [2,4],[2,5],[3,4],[3,5]  // equator
                    ];
                case 'icosahedron':
                    // 12 vertices - connect based on golden ratio geometry
                    const icoEdges = [];
                    for (let i = 0; i < this.vertices.length; i++) {
                        for (let j = i + 1; j < this.vertices.length; j++) {
                            const d = Math.hypot(
                                this.vertices[i].x - this.vertices[j].x,
                                this.vertices[i].y - this.vertices[j].y,
                                this.vertices[i].z - this.vertices[j].z
                            );
                            // Edge length for unit icosahedron is ~0.5-0.6
                            if (d < 0.8) icoEdges.push([i, j]);
                        }
                    }
                    return icoEdges;
                case 'dodecahedron':
                    // 20 vertices - connect based on distance
                    const dodEdges = [];
                    for (let i = 0; i < this.vertices.length; i++) {
                        for (let j = i + 1; j < this.vertices.length; j++) {
                            const d = Math.hypot(
                                this.vertices[i].x - this.vertices[j].x,
                                this.vertices[i].y - this.vertices[j].y,
                                this.vertices[i].z - this.vertices[j].z
                            );
                            // Edge length threshold for dodecahedron
                            if (d < 0.55) dodEdges.push([i, j]);
                        }
                    }
                    return dodEdges;
                default:
                    return [];
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: SurfaceFactory ‚Äî Creates surface instances
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class SurfaceFactory {
        static create(type) {
            const map = { 
                sphere: Sphere, 
                doublehelix: DoubleHelix,
                singlehelix: SingleHelix,
                triplehelix: TripleHelix,
                conicalhelix: ConicalHelix,
                torus: Torus, 
                spiraltorus: SpiralTorus,
                cylinder: Cylinder, 
                mobius: Mobius, 
                klein: Klein,
                trefoil: Trefoil,
                lissajous: Lissajous
            };
            if (map[type]) return new map[type]();
            if (['cube','tetrahedron','octahedron','icosahedron','dodecahedron'].includes(type)) {
                return new Polyhedron(type);
            }
            return new Sphere();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: MappingStrategy ‚Äî Converts n to angular coordinates
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class MappingStrategy {
        // Cache for prime indices
        static primeIndexCache = new Map();
        static primeGapCache = new Map();

        // Get prime index œÄ(n) - count of primes ‚â§ n
        static getPrimeIndex(n) {
            if (this.primeIndexCache.has(n)) return this.primeIndexCache.get(n);
            let count = 0;
            for (let i = 2; i <= n; i++) {
                if (PrimeMath.isPrime(i)) count++;
            }
            this.primeIndexCache.set(n, count);
            return count;
        }

        // Get gap to previous prime
        static getPrimeGap(n) {
            if (this.primeGapCache.has(n)) return this.primeGapCache.get(n);
            let prev = n - 1;
            while (prev > 1 && !PrimeMath.isPrime(prev)) prev--;
            const gap = prev > 1 ? n - prev : 0;
            this.primeGapCache.set(n, gap);
            return gap;
        }

        // Transform n based on mode (for composable modes)
        static transformN(n, maxN, isPrime, mode) {
            // Edge case: n=1 has no factors, return 1
            if (n <= 1) return 1;

            switch(mode) {
                case 'primeIndex':
                    if (isPrime) {
                        return this.getPrimeIndex(n);
                    } else {
                        // For composites, use average factor index
                        const factors = PrimeMath.factorize(n);
                        if (factors.length === 0) return 1; // Safety check
                        return factors.reduce((sum, f) => sum + this.getPrimeIndex(f), 0) / factors.length;
                    }

                case 'gapBased':
                    // Transform n by incorporating gap information
                    const gap = this.getPrimeGap(n);
                    // Scale n by gap ratio ‚Äî larger gaps push numbers further
                    return n * (1 + gap / 20);

                case 'residueFingerprint':
                    // Create a composite index from residues
                    const r2 = n % 2;
                    const r3 = n % 3;
                    const r5 = n % 5;
                    const r7 = n % 7;
                    // Combine using CRT-like weighting
                    return n + (r2 * 105 + r3 * 70 + r5 * 42 + r7 * 30) / 247;

                default:
                    return n;
            }
        }

        // Main mapping function - now with composable mode support
        static map(n, maxN, method, isPrime, mode = 'generic', surfaceType = 'sphere') {
            // NATIVE mode: special ‚Äî bypasses method entirely, geometry-aware
            if (mode === 'native') {
                return this.nativeMapping(n, maxN, isPrime, surfaceType);
            }

            // For composable modes: transform n first, then apply method
            let effectiveN = n;
            let effectiveMaxN = maxN;

            if (mode !== 'generic') {
                effectiveN = this.transformN(n, maxN, isPrime, mode);
                // Adjust maxN proportionally for proper scaling
                if (mode === 'primeIndex') {
                    effectiveMaxN = this.getPrimeIndex(maxN);
                } else if (mode === 'gapBased') {
                    effectiveMaxN = maxN * 1.5; // Approximate max scaling
                } else if (mode === 'residueFingerprint') {
                    effectiveMaxN = maxN * 1.5;
                }
            }

            const t = effectiveN / effectiveMaxN;

            // Now apply the selected METHOD to the (possibly transformed) n
            let theta, phi;

            switch(method) {
                case 'modular6': 
                    theta = (effectiveN % 6) * (Math.PI / 3) + effectiveN * 0.001; 
                    phi = Math.PI * t; 
                    break;
                case 'modular30': 
                    theta = (effectiveN % 30) * (Math.PI / 15) + effectiveN * 0.0002; 
                    phi = Math.PI * t; 
                    break;
                case 'log': 
                    theta = PrimeMath.GOLDEN_ANGLE * effectiveN; 
                    phi = Math.acos(1 - 2 * Math.log(effectiveN + 1) / Math.log(effectiveMaxN + 1)); 
                    break;
                case 'primeStrand': 
                    theta = PrimeMath.GOLDEN_ANGLE * effectiveN + (isPrime ? 0 : Math.PI); 
                    phi = Math.acos(1 - 2 * t); 
                    break;

                // CRT Residue Torus - divisibility appears as bands
                case 'crtTorus':
                    theta = 2 * Math.PI * (effectiveN % 210) / 210;
                    phi = 2 * Math.PI * (effectiveN % 143) / 143;
                    break;

                // Valuation 3D - prime powers become geometric axes
                // Uses ORIGINAL n for valuations (intrinsic property)
                case 'valuation3D':
                    const v2 = PrimeMath.valuation(n, 2);  // <-- ORIGINAL n
                    const v3 = PrimeMath.valuation(n, 3);  // <-- ORIGINAL n
                    const v5 = PrimeMath.valuation(n, 5);  // <-- ORIGINAL n
                    theta = Math.PI * 2 * (v2 + v3 * 0.1) / 10;
                    phi = Math.PI * (0.1 + 0.8 * Math.tanh((v2 + v3 + v5) / 3));
                    break;

                // Log Phase - makes multiplication closer to addition
                case 'logPhase':
                    const alpha = 0.5;
                    theta = 2 * Math.PI * alpha * Math.log(effectiveN + 1);
                    phi = Math.acos(1 - 2 * Math.log(effectiveN + 1) / Math.log(effectiveMaxN + 1));
                    break;

                // Log Helix - ChatGPT's recommended mapping for mult‚Üíadd
                case 'logHelix':
                    // Both theta AND z driven by log(n)
                    // This makes multiplication = addition geometrically!
                    const logN = Math.log(effectiveN + 1);
                    const logMax = Math.log(effectiveMaxN + 1);
                    theta = 2 * Math.PI * logN;  // angle proportional to log
                    phi = Math.acos(1 - 2 * logN / logMax);  // height also log-based
                    break;

                // Smallest Prime Factor bands
                // Uses ORIGINAL n for SPF (intrinsic property)
                case 'spfBands':
                    const spf = PrimeMath.smallestFactor(n);  // <-- ORIGINAL n
                    // SPF determines the "ring" (phi), n determines position in ring (theta)
                    theta = PrimeMath.GOLDEN_ANGLE * effectiveN;
                    // Map SPF to latitude bands: 2‚Üítop, 3‚Üínext, etc.
                    const spfIndex = [2,3,5,7,11,13,17,19,23,29,31].indexOf(spf);
                    phi = Math.PI * (0.1 + 0.8 * (spfIndex >= 0 ? spfIndex / 10 : 0.95));
                    break;

                // Smoothness mapping - smooth numbers cluster
                // NOTE: We use the ORIGINAL n for smoothness calculation, not effectiveN
                // because smoothness is an intrinsic property of n, not its transformed position
                case 'smoothness': {
                    // Use ORIGINAL n for smoothness (it's an intrinsic property of the number)
                    // but use effectiveN for the angular position (theta)
                    const smooth = PrimeMath.smoothness(n, 7);  // <-- ORIGINAL n, not effectiveN
                    const maxSmooth = Math.max(12, Math.ceil(Math.log2(maxN)));
                    theta = PrimeMath.GOLDEN_ANGLE * effectiveN;  // Position uses transformed n
                    const smoothRatio = Math.min(smooth / maxSmooth, 1);
                    // High smoothness ‚Üí LOW phi ‚Üí North pole (z positive)
                    // Low smoothness ‚Üí HIGH phi ‚Üí South pole (z negative)
                    phi = Math.PI * (0.95 - smoothRatio * 0.9);
                    break;
                }

                // CONTROL: Random mapping for hypothesis testing
                case '_randomControl':
                    theta = Math.random() * 2 * Math.PI;
                    phi = Math.acos(1 - 2 * Math.random());
                    break;

                default: // 'spiral' - Golden Spiral
                    theta = PrimeMath.GOLDEN_ANGLE * effectiveN; 
                    phi = Math.acos(1 - 2 * t);
            }

            return { t, theta, phi };
        }

        // Geometry-native mappings - each surface gets its natural coordinates
        static nativeMapping(n, maxN, isPrime, surfaceType) {
            const t = n / maxN;
            let theta, phi;

            switch(surfaceType) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SPHERE: Golden angle is already native ‚Äî keep it
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'sphere':
                    theta = PrimeMath.GOLDEN_ANGLE * n;
                    phi = Math.acos(1 - 2 * t);
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TORUS: Two independent cycles ‚Äî use mod relationships!
                // Major angle: mod 6 wheel (captures 2,3 structure)
                // Minor angle: mod 5 wheel (adds 5 structure)
                // This makes the torus geometry MEANINGFUL for residue classes
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'torus':
                case 'spiralTorus':
                    // Major circle: 6-fold (mod 6 residues)
                    theta = 2 * Math.PI * (n % 6) / 6 + (n / maxN) * 0.1; // slight progression
                    // Minor circle: 5-fold 
                    phi = 2 * Math.PI * (n % 5) / 5 + (n / maxN) * Math.PI * 2;
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // HELIX: Rotation + height ‚Äî use residue class + magnitude
                // Angle from mod 30 wheel (primorial), height from log(n)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'singleHelix':
                case 'conicalHelix':
                    // Angle: 30-fold primorial wheel (2√ó3√ó5)
                    theta = 2 * Math.PI * (n % 30) / 30;
                    // Height: logarithmic (compresses large numbers)
                    phi = Math.acos(1 - 2 * Math.log(n + 1) / Math.log(maxN + 1));
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // DOUBLE HELIX: Primes on one strand, composites on other
                // Native: strand determined by primality, position by index
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'doubleHelix':
                    // Strand offset based on primality
                    const strandOffset = isPrime ? 0 : Math.PI;
                    // Use prime index for primes, sequential for composites
                    if (isPrime) {
                        const pi = this.getPrimeIndex(n);
                        theta = PrimeMath.GOLDEN_ANGLE * pi + strandOffset;
                    } else {
                        theta = PrimeMath.GOLDEN_ANGLE * n * 0.5 + strandOffset;
                    }
                    phi = Math.acos(1 - 2 * t);
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TRIPLE HELIX: Three strands ‚Äî split by mod 3
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'tripleHelix':
                    const strand3 = n % 3;
                    theta = PrimeMath.GOLDEN_ANGLE * Math.floor(n / 3) + strand3 * (2 * Math.PI / 3);
                    phi = Math.acos(1 - 2 * t);
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CYLINDER: Angle from residue, height from value
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'cylinder':
                    theta = 2 * Math.PI * (n % 12) / 12; // 12-fold (2¬≤√ó3)
                    phi = Math.PI * t; // Linear height
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // M√ñBIUS: Single-sided ‚Äî twist encodes something?
                // Use mod 4 for the twist cycle
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'mobius':
                    theta = 2 * Math.PI * t; // Position along strip
                    phi = Math.PI * (n % 4) / 4; // Twist position
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // KLEIN BOTTLE: Non-orientable ‚Äî two cycles with twist
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'klein':
                    theta = 2 * Math.PI * (n % 10) / 10;
                    phi = 2 * Math.PI * t;
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TREFOIL KNOT: Three-fold symmetry
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'trefoil':
                    theta = 2 * Math.PI * t * 3; // 3 loops
                    phi = 2 * Math.PI * (n % 7) / 7; // 7-fold for variety
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LISSAJOUS: Frequency ratios ‚Äî use coprime modulii
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'lissajous':
                    theta = 2 * Math.PI * (n % 7) / 7;  // 7-cycle
                    phi = 2 * Math.PI * (n % 11) / 11; // 11-cycle (coprime to 7)
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // POLYHEDRA: Map to faces based on modular arithmetic
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                case 'icosahedron':
                    // 20 faces ‚Äî use mod 20
                    theta = 2 * Math.PI * (n % 20) / 20 + t * 0.05;
                    phi = Math.acos(1 - 2 * ((n % 5) / 5 + t * 0.1));
                    break;
                case 'dodecahedron':
                    // 12 faces ‚Äî use mod 12
                    theta = 2 * Math.PI * (n % 12) / 12 + t * 0.05;
                    phi = Math.acos(1 - 2 * ((n % 4) / 4 + t * 0.1));
                    break;
                case 'octahedron':
                    // 8 faces ‚Äî use mod 8
                    theta = 2 * Math.PI * (n % 8) / 8 + t * 0.05;
                    phi = Math.acos(1 - 2 * ((n % 3) / 3 + t * 0.1));
                    break;
                case 'tetrahedron':
                    // 4 faces ‚Äî use mod 4
                    theta = 2 * Math.PI * (n % 4) / 4 + t * 0.1;
                    phi = Math.acos(1 - 2 * ((n % 2) / 2 + t * 0.2));
                    break;
                case 'cube':
                    // 6 faces ‚Äî use mod 6
                    theta = 2 * Math.PI * (n % 6) / 6 + t * 0.05;
                    phi = Math.acos(1 - 2 * ((n % 3) / 3 + t * 0.1));
                    break;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // DEFAULT: Fall back to golden spiral
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                default:
                    theta = PrimeMath.GOLDEN_ANGLE * n;
                    phi = Math.acos(1 - 2 * t);
            }

            return { t, theta, phi };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: ColorScheme ‚Äî Handles color calculation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class ColorScheme {
        static TYPES = { 
            regular: {r:255, g:107, b:107}, 
            twin: {r:255, g:217, b:61}, 
            sophie: {r:78, g:205, b:196}, 
            mersenne: {r:157, g:78, b:221},
            supersingular: {r:0, g:255, b:136}, 
            safe: {r:255, g:102, b:178}, 
            composite: {r:60, g:60, b:80}, 
            semiprime: {r:120, g:100, b:140} 
        };

        static getColor(point, mode) {
            switch(mode) {
                case 'type': 
                    return point.primeType ? this.TYPES[point.primeType] : 
                           (point.isSemiprime ? this.TYPES.semiprime : this.TYPES.composite);
                case 'factor3': 
                    return this._byFactors(point.n);
                case 'primeIndex': 
                    return this._byPrimeIndex(point);
                case 'modular': 
                    return this._hsl((point.n * 137.5) % 360, 70, 50);

                // NEW: Smoothness coloring - bright = smooth, dark = hard
                case 'smoothnessColor':
                    return this._bySmoothness(point.n);

                // NEW: Omega coloring - by number of prime factors
                case 'omegaColor':
                    return this._byOmega(point.n);

                // NEW: SPF coloring - by smallest prime factor
                case 'spfColor':
                    return this._bySPF(point.n);

                // NEW: Residue coloring - mod 210 rainbow
                case 'residueColor':
                    return this._byResidue(point.n);

                default: 
                    return point.primeType ? this.TYPES[point.primeType] : this.TYPES.composite;
            }
        }

        // NEW: Color by smoothness score
        static _bySmoothness(n) {
            const smooth = PrimeMath.smoothness(n, 7);
            // Bright cyan for smooth, dark purple for rough
            const intensity = Math.min(smooth / 6, 1);
            return {
                r: Math.floor(50 + 150 * (1 - intensity)),
                g: Math.floor(50 + 205 * intensity),
                b: Math.floor(100 + 155 * intensity)
            };
        }

        // NEW: Color by omega (number of prime factors with multiplicity)
        static _byOmega(n) {
            const omega = PrimeMath.omega(n);
            // Distinct colors for different omega values
            const colors = [
                {r:100, g:100, b:100}, // 0 (n=1)
                {r:255, g:107, b:107}, // 1 (prime)
                {r:255, g:217, b:61},  // 2 (semiprime or prime¬≤)
                {r:78, g:205, b:196},  // 3
                {r:157, g:78, b:221},  // 4
                {r:0, g:255, b:136},   // 5
                {r:255, g:102, b:178}, // 6+
            ];
            return colors[Math.min(omega, 6)];
        }

        // NEW: Color by smallest prime factor
        static _bySPF(n) {
            const spf = PrimeMath.smallestFactor(n);
            // Map SPF to hue
            const spfMap = {2: 0, 3: 60, 5: 120, 7: 180, 11: 210, 13: 240, 17: 270, 19: 300};
            const hue = spfMap[spf] !== undefined ? spfMap[spf] : 330;
            // Primes get white tint
            const sat = PrimeMath.isPrime(n) ? 30 : 80;
            const light = PrimeMath.isPrime(n) ? 70 : 50;
            return this._hsl(hue, sat, light);
        }

        // NEW: Color by residue mod 210 (primorial)
        static _byResidue(n) {
            const residue = n % 210;
            const hue = (residue / 210) * 360;
            // Highlight residue classes coprime to 210
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const coprime = gcd(residue, 210) === 1;
            return this._hsl(hue, coprime ? 90 : 40, coprime ? 60 : 35);
        }

        static _byFactors(n) {
            const v2 = PrimeMath.primeExponent(n, 2);
            const v3 = PrimeMath.primeExponent(n, 3);
            const v5 = PrimeMath.primeExponent(n, 5);
            if (v2 === 0 && v3 === 0 && v5 === 0) {
                return PrimeMath.isPrime(n) ? {r:200, g:200, b:200} : {r:80, g:80, b:80};
            }
            return { 
                r: Math.min(255, v2*60+40), 
                g: Math.min(255, v3*80+40), 
                b: Math.min(255, v5*100+40) 
            };
        }

        static _byPrimeIndex(point) {
            if (!point.isPrime) return {r:80, g:80, b:80};
            let idx = 0; 
            for (let i = 2; i <= point.n; i++) if (PrimeMath.isPrime(i)) idx++;
            return this._hsl((idx * PrimeMath.PHI * 360) % 360, 80, 55);
        }

        static _hsl(h, s, l) {
            s /= 100; l /= 100;
            const c = (1 - Math.abs(2*l - 1)) * s;
            const x = c * (1 - Math.abs((h/60)%2 - 1));
            const m = l - c/2;
            let r, g, b;
            if (h < 60) {r=c; g=x; b=0;} 
            else if (h < 120) {r=x; g=c; b=0;} 
            else if (h < 180) {r=0; g=c; b=x;}
            else if (h < 240) {r=0; g=x; b=c;} 
            else if (h < 300) {r=x; g=0; b=c;} 
            else {r=c; g=0; b=x;}
            return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: Renderer ‚Äî Handles all canvas drawing
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class Renderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.rotation = { x: 0.3, y: 0 };
            this.zoom = 1.0;
            this.panOffset = { x: 0, y: 0 }; // NEW: pan offset
        }

        resize() { 
            this.canvas.width = this.canvas.parentElement.clientWidth; 
            this.canvas.height = this.canvas.parentElement.clientHeight; 
        }

        get cx() { return this.canvas.width / 2 + this.panOffset.x; }
        get cy() { return this.canvas.height / 2 + this.panOffset.y; }
        get scale() { return Math.min(this.canvas.width, this.canvas.height) * 0.38 * this.zoom; }

        project(p) {
            let {x, y, z} = p;
            const cosY = Math.cos(this.rotation.y), sinY = Math.sin(this.rotation.y);
            const x1 = x*cosY - z*sinY, z1 = x*sinY + z*cosY;
            const cosX = Math.cos(this.rotation.x), sinX = Math.sin(this.rotation.x);
            const y1 = y*cosX - z1*sinX, z2 = y*sinX + z1*cosX;
            const fov = 2.5, s = fov / (fov + z2 + 1.5);
            return { x: x1*s, y: y1*s, z: z2, scale: s };
        }

        clear() { 
            this.ctx.fillStyle = '#000'; 
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); 
        }

        drawWireframe(lines) {
            this.ctx.strokeStyle = 'rgba(78, 205, 196, 0.25)'; 
            this.ctx.lineWidth = 1;
            for (const line of lines) {
                this.ctx.beginPath();
                for (let i = 0; i < line.length; i++) {
                    const p = this.project(line[i]);
                    const sx = this.cx + p.x * this.scale;
                    const sy = this.cy - p.y * this.scale;
                    i === 0 ? this.ctx.moveTo(sx, sy) : this.ctx.lineTo(sx, sy);
                }
                this.ctx.stroke();
            }
        }

        drawPoint(point, size, highlight = false) {
            const proj = this.project(point);
            const sx = this.cx + proj.x * this.scale;
            const sy = this.cy - proj.y * this.scale;
            const finalSize = size * proj.scale;
            const alpha = highlight ? 1 : (0.4 + proj.scale * 0.6);

            if (highlight) { 
                this.ctx.shadowColor = point.hex; 
                this.ctx.shadowBlur = 15; 
            }

            this.ctx.globalAlpha = alpha; 
            this.ctx.fillStyle = point.hex;
            this.ctx.beginPath(); 
            this.ctx.arc(sx, sy, Math.max(1.5, finalSize), 0, Math.PI * 2); 
            this.ctx.fill();
            this.ctx.shadowBlur = 0; 
            this.ctx.globalAlpha = 1;
        }

        drawConnection(from, to, progress, fromHex, toHex) {
            const p1 = this.project(from), p2 = this.project(to);
            const sx1 = this.cx + p1.x * this.scale, sy1 = this.cy - p1.y * this.scale;
            const sx2 = this.cx + p2.x * this.scale, sy2 = this.cy - p2.y * this.scale;

            const grad = this.ctx.createLinearGradient(sx1, sy1, sx2, sy2);
            grad.addColorStop(0, fromHex); 
            grad.addColorStop(1, toHex);

            this.ctx.strokeStyle = grad; 
            this.ctx.lineWidth = 3; 
            this.ctx.globalAlpha = progress * 0.9;
            this.ctx.beginPath(); 
            this.ctx.moveTo(sx1, sy1);
            const endX = p1.x + (p2.x - p1.x) * progress;
            const endY = p1.y + (p2.y - p1.y) * progress;
            this.ctx.lineTo(this.cx + endX * this.scale, this.cy - endY * this.scale); 
            this.ctx.stroke(); 
            this.ctx.globalAlpha = 1;
        }

        drawLabel(point, text, color = '#fff') {
            const proj = this.project(point);
            this.ctx.fillStyle = color; 
            this.ctx.font = 'bold 12px sans-serif'; 
            this.ctx.textAlign = 'center';
            this.ctx.fillText(text, this.cx + proj.x * this.scale, this.cy - proj.y * this.scale - 16);
        }

        // NEW: Draw error vector (dashed arrow from predicted to actual)
        drawErrorVector(from, to, color = '#ff6b6b') {
            const p1 = this.project(from), p2 = this.project(to);
            const sx1 = this.cx + p1.x * this.scale, sy1 = this.cy - p1.y * this.scale;
            const sx2 = this.cx + p2.x * this.scale, sy2 = this.cy - p2.y * this.scale;

            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 3]);
            this.ctx.beginPath();
            this.ctx.moveTo(sx1, sy1);
            this.ctx.lineTo(sx2, sy2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);

            // Arrowhead
            const angle = Math.atan2(sy2 - sy1, sx2 - sx1);
            const headLen = 10;
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.moveTo(sx2, sy2);
            this.ctx.lineTo(sx2 - headLen * Math.cos(angle - Math.PI/6), sy2 - headLen * Math.sin(angle - Math.PI/6));
            this.ctx.lineTo(sx2 - headLen * Math.cos(angle + Math.PI/6), sy2 - headLen * Math.sin(angle + Math.PI/6));
            this.ctx.closePath();
            this.ctx.fill();
        }

        // NEW: Draw tree descent path
        drawTreePath(points, progress) {
            if (points.length < 2) return;

            const totalSegments = points.length - 1;
            const currentSegment = Math.floor(progress * totalSegments);
            const segmentProgress = (progress * totalSegments) % 1;

            for (let i = 0; i < Math.min(currentSegment + 1, totalSegments); i++) {
                const from = points[i], to = points[i + 1];
                const p1 = this.project(from), p2 = this.project(to);
                const sx1 = this.cx + p1.x * this.scale, sy1 = this.cy - p1.y * this.scale;
                const sx2 = this.cx + p2.x * this.scale, sy2 = this.cy - p2.y * this.scale;

                const prog = (i < currentSegment) ? 1 : segmentProgress;
                const endX = sx1 + (sx2 - sx1) * prog;
                const endY = sy1 + (sy2 - sy1) * prog;

                this.ctx.strokeStyle = `hsl(${280 - i * 20}, 70%, 60%)`;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(sx1, sy1);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
            }
        }

        findPointAt(mx, my, points) {
            let closest = null, minDist = 15 / this.zoom;
            for (const p of points) {
                const proj = this.project(p);
                const sx = this.cx + proj.x * this.scale;
                const sy = this.cy - proj.y * this.scale;
                const d = Math.hypot(mx - sx, my - sy);
                if (d < minDist) { minDist = d; closest = p; }
            }
            return closest;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: CollapseAnimation ‚Äî Factorization collapse animation state
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class CollapseAnimation {
        constructor() { 
            this.reset(); 
            this.onComplete = null; 
        }

        reset() { 
            this.phase = 0; 
            this.progress = 0; 
            this.target = null; 
            this.factorPoints = []; 
        }

        select(target) { 
            this.target = target; 
            this.phase = 1; 
            this.progress = 0; 
            this.factorPoints = []; 
        }

        start(target, factorPoints) { 
            this.target = target; 
            this.factorPoints = factorPoints; 
            this.phase = 2; 
            this.progress = 0; 
        }

        update() { 
            if (this.phase === 2) { 
                this.progress += 0.025; 
                if (this.progress >= 1.5) { 
                    this.phase = 3; 
                    if (this.onComplete) this.onComplete(); 
                } 
            } 
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEW CLASS: TreeAnimation ‚Äî Factor tree descent animation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class TreeAnimation {
        constructor() {
            this.reset();
            this.onComplete = null;
        }

        reset() {
            this.active = false;
            this.progress = 0;
            this.pathPoints = [];
            this.steps = [];
        }

        start(pathPoints, steps) {
            this.pathPoints = pathPoints;
            this.steps = steps;
            this.progress = 0;
            this.active = true;
        }

        update() {
            if (this.active) {
                this.progress += 0.008;
                if (this.progress >= 1) {
                    this.active = false;
                    if (this.onComplete) this.onComplete();
                }
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEW CLASS: MultiplicationLab ‚Äî Handles multiplication error analysis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class MultiplicationLab {
        constructor(explorer) {
            this.explorer = explorer;
            this.showVector = false;
            this.currentResult = null;
            this.errorCache = [];
            this.featureMode = 'position'; // position, log, valuation, mixed
        }

        getPosition(n) {
            const point = new Point(n);
            const maxN = Math.max(n, this.explorer.maxN);
            const {t, theta, phi} = MappingStrategy.map(n, maxN, this.explorer.mappingMethod, point.isPrime, this.explorer.mappingMode, this.explorer.surfaceType);
            const pos = this.explorer.surface.mapPoint(t, theta, phi, point.isPrime);
            point.setPosition(pos.x, pos.y, pos.z);
            point.setColor(ColorScheme.getColor(point, this.explorer.colorMode));
            return point;
        }

        // NEW: Get feature vector based on current mode
        getFeature(n) {
            const maxN = this.explorer.maxN;

            switch (this.featureMode) {
                case 'log':
                    // Log feature: log(pq) = log(p) + log(q) exactly
                    // Normalized to ~[0,1] range
                    const logMax = Math.log(maxN);
                    return { 
                        x: Math.log(n) / logMax, 
                        y: Math.log(n) / Math.log(2) / Math.log2(maxN),
                        z: Math.log(n) / Math.log(3) / (Math.log(maxN) / Math.log(3))
                    };

                case 'valuation':
                    // Valuation feature: v_p(pq) = v_p(p) + v_p(q) exactly
                    // Capped at 8 for normalization
                    return {
                        x: Math.min(PrimeMath.valuation(n, 2), 8) / 8,
                        y: Math.min(PrimeMath.valuation(n, 3), 8) / 8,
                        z: Math.min(PrimeMath.valuation(n, 5), 8) / 8
                    };

                case 'mixed':
                    // Mixed: combine log, valuations, and residues
                    const logN = Math.log(n) / Math.log(maxN);
                    const v2 = Math.min(PrimeMath.valuation(n, 2), 8) / 8;
                    const v3 = Math.min(PrimeMath.valuation(n, 3), 8) / 8;
                    return {
                        x: logN,
                        y: (v2 + v3) / 2,
                        z: (n % 30) / 30
                    };

                case 'residue':
                    // Residue fingerprint - normalized
                    return {
                        x: (n % 7) / 7,
                        y: (n % 11) / 11,
                        z: (n % 13) / 13
                    };

                case 'residueZero':
                    // NEW: Residue zero-distance - how close to divisible?
                    // Lower = closer to divisible by that prime
                    // This is where factor detection becomes visual!
                    const r7 = Math.min(n % 7, 7 - (n % 7)) / 3.5;  // 0 = divisible
                    const r11 = Math.min(n % 11, 11 - (n % 11)) / 5.5;
                    const r13 = Math.min(n % 13, 13 - (n % 13)) / 6.5;
                    return { x: r7, y: r11, z: r13 };

                default: // 'position'
                    const point = this.getPosition(n);
                    return { x: point.x, y: point.y, z: point.z };
            }
        }

        compute(p, q) {
            const pointP = this.getPosition(p);
            const pointQ = this.getPosition(q);
            const pointPQ = this.getPosition(p * q);

            // Get features based on mode
            const featP = this.getFeature(p);
            const featQ = this.getFeature(q);
            const featPQ = this.getFeature(p * q);

            const predicted = {
                x: featP.x + featQ.x,
                y: featP.y + featQ.y,
                z: featP.z + featQ.z
            };

            const actual = { x: featPQ.x, y: featPQ.y, z: featPQ.z };

            const error = Math.sqrt(
                (predicted.x - actual.x) ** 2 +
                (predicted.y - actual.y) ** 2 +
                (predicted.z - actual.z) ** 2
            );

            // Store both position (for visualization) and feature data
            this.currentResult = { 
                p, q, 
                pointP, pointQ, pointPQ, 
                featP, featQ, featPQ,
                predicted, actual, 
                error,
                featureMode: this.featureMode
            };
            return this.currentResult;
        }

        findMinimalErrorPairs(limit = 50, topN = 10) {
            const results = [];
            const primes = [];

            // Save current result before searching (may be null/undefined)
            const savedResult = this.currentResult || null;

            for (let i = 2; i <= limit; i++) {
                if (PrimeMath.isPrime(i)) primes.push(i);
            }

            for (let i = 0; i < primes.length; i++) {
                for (let j = i; j < primes.length; j++) {
                    const result = this.compute(primes[i], primes[j]);
                    results.push({ p: primes[i], q: primes[j], error: result.error });
                }
            }

            results.sort((a, b) => a.error - b.error);
            this.errorCache = results;

            // Restore the original currentResult (only if it existed)
            if (savedResult) {
                this.currentResult = savedResult;
            }

            return results.slice(0, topN);
        }

        getRank(error) {
            if (this.errorCache.length === 0) {
                this.findMinimalErrorPairs(50, 50);
            }

            let rank = 1;
            for (const r of this.errorCache) {
                if (error <= r.error) break;
                rank++;
            }

            return { rank, total: this.errorCache.length };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEW CLASS: TopologyAnalyzer ‚Äî Measures structural importance of positions
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class TopologyAnalyzer {
        constructor(explorer) {
            this.explorer = explorer;
            this.hubScores = new Map(); // n -> hub score
            this.radius = 0.15;
            this.colorByHub = false;
        }

        // Calculate hub score for each point (number of neighbors within radius)
        analyze() {
            this.hubScores.clear();
            this.cachedMaxScore = null; // Clear cache
            const points = this.explorer.points;

            // For each point, count neighbors within radius
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                let neighbors = 0;
                let totalDist = 0;

                for (let j = 0; j < points.length; j++) {
                    if (i === j) continue;
                    const q = points[j];
                    const d = Math.sqrt(
                        (p.x - q.x) ** 2 + 
                        (p.y - q.y) ** 2 + 
                        (p.z - q.z) ** 2
                    );
                    if (d < this.radius) {
                        neighbors++;
                        totalDist += d;
                    }
                }

                // Hub score = neighbor count (higher = more central/hub-like)
                // Could also weight by inverse distance
                this.hubScores.set(p.n, {
                    neighbors,
                    avgDist: neighbors > 0 ? totalDist / neighbors : 0,
                    score: neighbors
                });
            }

            return this.getStatistics();
        }

        getStatistics() {
            const points = this.explorer.points;

            // Separate primes and composites
            const primeScores = [];
            const compositeScores = [];
            const allScores = [];

            for (const p of points) {
                const data = this.hubScores.get(p.n);
                if (!data) continue;

                allScores.push({ n: p.n, score: data.score, isPrime: p.isPrime });

                if (p.isPrime) {
                    primeScores.push(data.score);
                } else {
                    compositeScores.push(data.score);
                }
            }

            // Calculate averages
            const primeAvg = primeScores.length > 0 
                ? primeScores.reduce((a, b) => a + b, 0) / primeScores.length : 0;
            const compositeAvg = compositeScores.length > 0 
                ? compositeScores.reduce((a, b) => a + b, 0) / compositeScores.length : 0;

            // Find top hub positions
            allScores.sort((a, b) => b.score - a.score);
            const topHubs = allScores.slice(0, 10);

            // Count primes vs composites in top 10%
            const top10Percent = Math.floor(allScores.length * 0.1);
            const topPositions = allScores.slice(0, top10Percent);
            const primesInTop = topPositions.filter(x => x.isPrime).length;
            const compositesInTop = topPositions.length - primesInTop;

            // Calculate max score for normalization
            const maxScore = allScores.length > 0 ? allScores[0].score : 1;

            return {
                primeAvg,
                compositeAvg,
                primeCount: primeScores.length,
                compositeCount: compositeScores.length,
                topHubs,
                primesInTop,
                compositesInTop,
                top10PercentSize: top10Percent,
                maxScore,
                ratio: compositeAvg / (primeAvg || 1) // How much higher are composite scores?
            };
        }

        // Get color based on hub score
        getHubColor(n) {
            const data = this.hubScores.get(n);
            if (!data) return null;

            // Use cached maxScore instead of recalculating every time
            if (!this.cachedMaxScore) {
                let max = 0;
                for (const [_, d] of this.hubScores) {
                    if (d.score > max) max = d.score;
                }
                this.cachedMaxScore = max || 1;
            }

            const normalized = data.score / this.cachedMaxScore;

            // Gradient from blue (low) -> yellow (med) -> red (high hub)
            if (normalized > 0.7) {
                return { r: 255, g: 50, b: 50 }; // Hot red - high hub
            } else if (normalized > 0.4) {
                return { r: 255, g: 200, b: 50 }; // Yellow - medium
            } else if (normalized > 0.2) {
                return { r: 50, g: 200, b: 200 }; // Cyan - low-medium
            } else {
                return { r: 50, g: 100, b: 200 }; // Blue - low hub
            }
        }

        // NEW: Run analysis across multiple configurations
        batchAnalysis(explorer) {
            const surfaces = ['sphere', 'icosahedron', 'cube', 'torus', 'dodecahedron'];
            const mappings = ['spiral', 'modular6', 'modular30', 'log'];
            const results = [];

            const originalSurface = explorer.surface;
            const originalMapping = explorer.mappingMethod;

            for (const surf of surfaces) {
                for (const map of mappings) {
                    // Temporarily change config
                    explorer.surface = SurfaceFactory.create(surf);
                    explorer.mappingMethod = map;
                    explorer.generatePoints();

                    // Analyze
                    const stats = this.analyze();

                    // Count composites in top 10 specifically
                    const allScores = [];
                    for (const p of explorer.points) {
                        const data = this.hubScores.get(p.n);
                        if (data) allScores.push({ isPrime: p.isPrime, score: data.score });
                    }
                    allScores.sort((a, b) => b.score - a.score);
                    const top10 = allScores.slice(0, 10);
                    const compositesInTop10 = top10.filter(x => !x.isPrime).length;

                    results.push({
                        surface: surf,
                        mapping: map,
                        ratio: stats.ratio,
                        primeAvg: stats.primeAvg,
                        compositeAvg: stats.compositeAvg,
                        compositesInTop10,
                        primesInTop10: 10 - compositesInTop10
                    });
                }
            }

            // Restore original config
            explorer.surface = originalSurface;
            explorer.mappingMethod = originalMapping;
            explorer.generatePoints();

            return results;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VALIDATION SUITE ‚Äî Hypothesis Testing for Hub Effect
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // 1. BASE-RATE CORRECTED EXPECTATION
        computeExpectedVsObserved(topK = 10) {
            const points = this.explorer.points;
            const totalPrimes = points.filter(p => p.isPrime).length;
            const totalPoints = points.length;
            const primeRate = totalPrimes / totalPoints;

            // Get actual top K hub positions
            const allScores = [];
            for (const p of points) {
                const data = this.hubScores.get(p.n);
                if (data) allScores.push({ n: p.n, isPrime: p.isPrime, score: data.score });
            }
            allScores.sort((a, b) => b.score - a.score);
            const topHubs = allScores.slice(0, topK);

            const observedPrimes = topHubs.filter(x => x.isPrime).length;
            const expectedPrimes = primeRate * topK;

            // Calculate deviation
            const deviation = observedPrimes - expectedPrimes;
            const deviationPercent = ((observedPrimes - expectedPrimes) / expectedPrimes) * 100;

            return {
                topK,
                totalPoints,
                totalPrimes,
                primeRate: (primeRate * 100).toFixed(2) + '%',
                expectedPrimes: expectedPrimes.toFixed(2),
                observedPrimes,
                deviation: deviation.toFixed(2),
                deviationPercent: deviationPercent.toFixed(1) + '%',
                direction: deviation > 0 ? 'MORE primes than expected' : 
                          deviation < 0 ? 'FEWER primes than expected' : 'Exactly as expected'
            };
        }

        // 2. PERMUTATION TEST ‚Äî Gold standard significance test
        permutationTest(topK = 10, iterations = 1000) {
            const points = this.explorer.points;
            const primeIndices = new Set(points.filter(p => p.isPrime).map((_, i) => i));
            const totalPrimes = primeIndices.size;

            // Get current scores in order
            const allScores = [];
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const data = this.hubScores.get(p.n);
                if (data) allScores.push({ idx: i, score: data.score, isPrime: p.isPrime });
            }
            allScores.sort((a, b) => b.score - a.score);

            // Observed: primes in top K
            const observedPrimes = allScores.slice(0, topK).filter(x => x.isPrime).length;

            // Permutation: shuffle prime labels, count how often we get <= observed
            let countAsExtremeOrMore = 0;
            const permutedCounts = [];

            for (let iter = 0; iter < iterations; iter++) {
                // Randomly assign "prime" to totalPrimes random positions
                const shuffledPrimes = new Set();
                const indices = [...Array(points.length).keys()];

                // Fisher-Yates shuffle first totalPrimes
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                for (let i = 0; i < totalPrimes; i++) {
                    shuffledPrimes.add(indices[i]);
                }

                // Count "primes" in top K positions (by hub score)
                let primesInTop = 0;
                for (let i = 0; i < topK; i++) {
                    if (shuffledPrimes.has(allScores[i].idx)) primesInTop++;
                }

                permutedCounts.push(primesInTop);

                // If observedPrimes <= random, it means primes avoid hubs
                // If observedPrimes >= random, it means primes prefer hubs
                if (primesInTop <= observedPrimes) countAsExtremeOrMore++;
            }

            // p-value: fraction of permutations with as few or fewer primes
            const pValue = countAsExtremeOrMore / iterations;

            // Calculate distribution stats
            const mean = permutedCounts.reduce((a, b) => a + b, 0) / iterations;
            const sorted = [...permutedCounts].sort((a, b) => a - b);
            const median = sorted[Math.floor(iterations / 2)];
            const min = sorted[0];
            const max = sorted[sorted.length - 1];

            return {
                topK,
                iterations,
                observedPrimes,
                expectedMean: mean.toFixed(2),
                expectedMedian: median,
                expectedRange: `${min}-${max}`,
                pValue: pValue.toFixed(4),
                significant: pValue < 0.05,
                interpretation: pValue < 0.05 
                    ? (observedPrimes < mean ? '‚úÖ SIGNIFICANT: Primes AVOID hubs!' : '‚úÖ SIGNIFICANT: Primes PREFER hubs!')
                    : '‚ùå NOT SIGNIFICANT: No hub preference detected'
            };
        }

        // 3. MAPPING CONTROL ‚Äî Test with random angles instead of golden spiral
        mappingControlTest(topK = 10, iterations = 100) {
            const explorer = this.explorer;
            const originalMapping = explorer.mappingMethod;
            const results = [];

            // Test with current mapping
            this.analyze();
            const currentResult = this.computeExpectedVsObserved(topK);
            results.push({
                mapping: originalMapping,
                observedPrimes: currentResult.observedPrimes,
                expected: parseFloat(currentResult.expectedPrimes)
            });

            // Test with randomized angles (multiple times)
            const randomObserved = [];
            for (let iter = 0; iter < iterations; iter++) {
                // Temporarily use random mapping
                explorer._randomSeed = iter;
                explorer.mappingMethod = '_randomControl';
                explorer.generatePoints();
                this.analyze();
                const randResult = this.computeExpectedVsObserved(topK);
                randomObserved.push(randResult.observedPrimes);
            }

            // Restore
            explorer.mappingMethod = originalMapping;
            explorer.generatePoints();
            this.analyze();

            const randomMean = randomObserved.reduce((a, b) => a + b, 0) / iterations;
            const randomSorted = [...randomObserved].sort((a, b) => a - b);

            return {
                topK,
                currentMapping: originalMapping,
                currentObserved: currentResult.observedPrimes,
                randomMean: randomMean.toFixed(2),
                randomRange: `${randomSorted[0]}-${randomSorted[randomSorted.length - 1]}`,
                difference: (currentResult.observedPrimes - randomMean).toFixed(2),
                interpretation: Math.abs(currentResult.observedPrimes - randomMean) < 1 
                    ? '‚ùå No difference from random ‚Äî effect is likely artifact of base rate'
                    : `‚ö†Ô∏è Difference of ${Math.abs(currentResult.observedPrimes - randomMean).toFixed(1)} primes ‚Äî may be geometry effect`
            };
        }

        // 4. N-SCALING TEST ‚Äî Does effect hold at different scales?
        nScalingTest(topK = 10, nValues = [3000, 5000, 10000, 15000]) {
            const explorer = this.explorer;
            const originalMaxN = explorer.maxN;
            const results = [];

            for (const n of nValues) {
                explorer.maxN = n;
                explorer.generatePoints();
                this.analyze();

                const stats = this.computeExpectedVsObserved(topK);
                const permTest = this.permutationTest(topK, 200); // Fewer iterations for speed

                results.push({
                    maxN: n,
                    totalPoints: stats.totalPoints,
                    primeRate: stats.primeRate,
                    expected: parseFloat(stats.expectedPrimes),
                    observed: stats.observedPrimes,
                    deviation: stats.deviation,
                    pValue: permTest.pValue,
                    significant: permTest.significant
                });
            }

            // Restore
            explorer.maxN = originalMaxN;
            explorer.generatePoints();
            this.analyze();

            // Check consistency
            const significantCount = results.filter(r => r.significant).length;
            const directions = results.map(r => parseFloat(r.deviation) > 0 ? 'more' : 'fewer');
            const consistent = new Set(directions).size === 1;

            return {
                results,
                consistentDirection: consistent,
                significantAtAllScales: significantCount === results.length,
                interpretation: significantCount === results.length && consistent
                    ? '‚úÖ Effect consistent across scales ‚Äî likely real!'
                    : significantCount === 0
                    ? '‚ùå No significant effect at any scale ‚Äî null hypothesis stands'
                    : `‚ö†Ô∏è Mixed results (${significantCount}/${results.length} significant) ‚Äî inconclusive`
            };
        }

        // 5. HUB RADIUS SENSITIVITY ‚Äî Does effect depend on radius definition?
        radiusSensitivityTest(topK = 10, radii = [0.08, 0.12, 0.15, 0.20, 0.25]) {
            const originalRadius = this.radius;
            const results = [];

            for (const r of radii) {
                this.radius = r;
                this.analyze();

                const stats = this.computeExpectedVsObserved(topK);
                const permTest = this.permutationTest(topK, 200);

                results.push({
                    radius: r,
                    expected: parseFloat(stats.expectedPrimes),
                    observed: stats.observedPrimes,
                    deviation: stats.deviation,
                    pValue: permTest.pValue,
                    significant: permTest.significant
                });
            }

            // Restore
            this.radius = originalRadius;
            this.analyze();

            const significantCount = results.filter(r => r.significant).length;

            return {
                results,
                robustAcrossRadii: significantCount >= radii.length - 1,
                interpretation: significantCount >= radii.length - 1
                    ? '‚úÖ Effect robust across different hub definitions'
                    : significantCount === 0
                    ? '‚ùå No effect at any radius ‚Äî null hypothesis stands'
                    : `‚ö†Ô∏è Effect appears at ${significantCount}/${radii.length} radii ‚Äî sensitive to definition`
            };
        }

        // FULL VALIDATION SUITE ‚Äî Run all tests
        runFullValidation(topK = 10) {
            console.log('üî¨ Running full validation suite...');

            // Must analyze first
            this.analyze();

            const results = {
                timestamp: new Date().toISOString(),
                config: {
                    surface: this.explorer.surface.name,
                    surfaceType: this.explorer.surfaceType,
                    mapping: this.explorer.mappingMethod,
                    mappingMode: this.explorer.mappingMode,
                    maxN: this.explorer.maxN,
                    hubRadius: this.radius,
                    topK
                },
                tests: {}
            };

            console.log('  1/5 Base-rate correction...');
            results.tests.baseRate = this.computeExpectedVsObserved(topK);

            console.log('  2/5 Permutation test (1000 iterations)...');
            results.tests.permutation = this.permutationTest(topK, 1000);

            console.log('  3/5 N-scaling test...');
            results.tests.nScaling = this.nScalingTest(topK, [3000, 5000, 10000]);

            console.log('  4/5 Radius sensitivity...');
            results.tests.radiusSensitivity = this.radiusSensitivityTest(topK, [0.10, 0.15, 0.20]);

            // Overall verdict
            const verdicts = [
                results.tests.permutation.significant,
                results.tests.nScaling.significantAtAllScales,
                results.tests.radiusSensitivity.robustAcrossRadii
            ];
            const passCount = verdicts.filter(v => v).length;

            results.verdict = {
                testsRun: 4,
                testsPassed: passCount,
                conclusion: passCount >= 3 
                    ? 'üèÜ DISCOVERY: Hub effect is REAL and robust!'
                    : passCount >= 2
                    ? '‚ö†Ô∏è INCONCLUSIVE: Some evidence, needs more investigation'
                    : passCount === 1
                    ? 'üîç WEAK: Effect appears in one test only ‚Äî likely artifact'
                    : '‚ùå NULL: No hub effect detected ‚Äî hypothesis falsified'
            };

            console.log('‚úÖ Validation complete:', results.verdict.conclusion);

            return results;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CROSS-MODE VALIDATION ‚Äî Test hypothesis across all mapping modes
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        runCrossModeValidation(topK = 10) {
            console.log('üîÑ Running cross-mode validation...');

            const modes = ['generic', 'native', 'primeIndex', 'gapBased', 'residueFingerprint'];
            const originalMode = this.explorer.mappingMode;
            const results = {
                timestamp: new Date().toISOString(),
                config: {
                    surface: this.explorer.surface.name,
                    surfaceType: this.explorer.surfaceType,
                    mapping: this.explorer.mappingMethod,
                    maxN: this.explorer.maxN,
                    hubRadius: this.radius,
                    topK
                },
                modeResults: {},
                summary: {}
            };

            // Test each mode
            for (const mode of modes) {
                console.log(`  Testing mode: ${mode}...`);

                // Switch mode and regenerate
                this.explorer.mappingMode = mode;
                this.explorer.generatePoints();

                // Re-analyze topology and get stats
                const stats = this.analyze();

                // Run core tests
                const baseRate = this.computeExpectedVsObserved(topK);
                const permutation = this.permutationTest(topK, 500); // Fewer iterations for speed

                // Get top hubs from statistics
                const topHubs = stats.topHubs || [];

                // Compute composite ratio in top hubs
                const topKHubs = [];
                const allPoints = [...this.explorer.points].map(p => ({
                    ...p,
                    neighborCount: this.hubScores.get(p.n)?.neighbors || 0
                })).sort((a, b) => b.neighborCount - a.neighborCount).slice(0, topK);

                const compositesInTop = allPoints.filter(p => !p.isPrime).length;
                const compositeRatio = compositesInTop / topK;

                // Expected composite ratio
                const totalComposites = this.explorer.points.filter(p => !p.isPrime).length;
                const expectedRatio = totalComposites / this.explorer.points.length;

                results.modeResults[mode] = {
                    compositeRatio,
                    expectedRatio,
                    enrichment: expectedRatio > 0 ? compositeRatio / expectedRatio : 1,
                    pValue: permutation.pValue,
                    significant: permutation.significant,
                    topHubTypes: allPoints.slice(0, 5).map(p => ({
                        n: p.n,
                        type: p.isPrime ? 'prime' : (p.isSemiprime ? 'semi' : 'comp'),
                        neighbors: p.neighborCount
                    }))
                };
            }

            // Restore original mode
            this.explorer.mappingMode = originalMode;
            this.explorer.generatePoints();
            this.analyze();

            // Summary statistics
            const enrichments = Object.values(results.modeResults).map(r => r.enrichment);
            const significantModes = Object.entries(results.modeResults)
                .filter(([_, r]) => r.significant)
                .map(([mode, _]) => mode);

            results.summary = {
                modesTestedCount: modes.length,
                significantModes: significantModes,
                significantCount: significantModes.length,
                avgEnrichment: enrichments.reduce((a, b) => a + b, 0) / enrichments.length,
                maxEnrichment: Math.max(...enrichments),
                minEnrichment: Math.min(...enrichments),
                modeWithMaxEnrichment: Object.entries(results.modeResults)
                    .sort((a, b) => b[1].enrichment - a[1].enrichment)[0][0],
                conclusion: significantModes.length >= 3
                    ? 'üèÜ ROBUST: Effect persists across multiple mapping modes!'
                    : significantModes.length >= 1
                    ? '‚ö†Ô∏è MODE-DEPENDENT: Effect only in some modes ‚Äî may be mapping artifact'
                    : '‚ùå NULL: No effect in any mode ‚Äî hypothesis falsified'
            };

            console.log('‚úÖ Cross-mode validation complete:', results.summary.conclusion);

            return results;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GEOMETRY COMPARISON ‚Äî Test same mode across different surfaces
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        runGeometryComparison(topK = 10) {
            console.log('üî∑ Running geometry comparison...');

            const surfaces = ['sphere', 'torus', 'singleHelix', 'doubleHelix', 'cylinder'];
            const originalSurface = this.explorer.surfaceType;
            const results = {
                timestamp: new Date().toISOString(),
                config: {
                    mappingMode: this.explorer.mappingMode,
                    mapping: this.explorer.mappingMethod,
                    maxN: this.explorer.maxN,
                    hubRadius: this.radius,
                    topK
                },
                surfaceResults: {},
                summary: {}
            };

            for (const surface of surfaces) {
                console.log(`  Testing surface: ${surface}...`);

                this.explorer.setSurface(surface);
                const stats = this.analyze();

                const permutation = this.permutationTest(topK, 500);

                // Get top hubs from hubScores
                const allPoints = [...this.explorer.points].map(p => ({
                    ...p,
                    neighborCount: this.hubScores.get(p.n)?.neighbors || 0
                })).sort((a, b) => b.neighborCount - a.neighborCount).slice(0, topK);

                const compositesInTop = allPoints.filter(p => !p.isPrime).length;

                results.surfaceResults[surface] = {
                    compositeRatio: compositesInTop / topK,
                    pValue: permutation.pValue,
                    significant: permutation.significant,
                    topHubExample: allPoints[0] ? { n: allPoints[0].n, neighbors: allPoints[0].neighborCount } : null
                };
            }

            // Restore
            this.explorer.setSurface(originalSurface);
            this.analyze();

            const significantSurfaces = Object.entries(results.surfaceResults)
                .filter(([_, r]) => r.significant)
                .map(([s, _]) => s);

            results.summary = {
                surfacesTestedCount: surfaces.length,
                significantSurfaces,
                significantCount: significantSurfaces.length,
                conclusion: significantSurfaces.length >= 3
                    ? 'üèÜ GEOMETRY-INDEPENDENT: Effect persists across surfaces!'
                    : significantSurfaces.length >= 1
                    ? '‚ö†Ô∏è GEOMETRY-DEPENDENT: Effect only on some surfaces'
                    : '‚ùå NULL: No effect on any surface'
            };

            return results;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: ResonanceAnalyzer ‚Äî Does N "resonate" with its factors?
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class ResonanceAnalyzer {
        constructor(explorer) {
            this.explorer = explorer;
        }

        // Factor a number (simple trial division for small numbers)
        factor(n) {
            if (n < 2) return [];
            const factors = [];
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                while (temp % p === 0) {
                    factors.push(p);
                    temp = temp / p;
                }
            }
            if (temp > 1) factors.push(temp);
            return factors;
        }

        // Check if semiprime
        isSemiprime(n) {
            const factors = this.factor(n);
            return factors.length === 2;
        }

        // Get position of a number on current surface
        getPosition(n) {
            const point = this.explorer.points.find(p => p.n === n);
            if (point) return { x: point.x, y: point.y, z: point.z };

            // Calculate position if not in current range
            // Use n itself as the scale reference to keep t in valid range
            const effectiveMax = Math.max(n, this.explorer.maxN);
            const t = n / effectiveMax;
            const mapping = MappingStrategy.map(n, effectiveMax, this.explorer.mappingMethod, PrimeMath.isPrime(n), this.explorer.mappingMode, this.explorer.surfaceType);
            return this.explorer.surface.mapPoint(t, mapping.theta, mapping.phi, PrimeMath.isPrime(n));
        }

        // Compute distance between two positions
        distance(pos1, pos2) {
            return Math.sqrt(
                (pos1.x - pos2.x) ** 2 +
                (pos1.y - pos2.y) ** 2 +
                (pos1.z - pos2.z) ** 2
            );
        }

        // Compute resonance spectrum for N
        computeSpectrum(n) {
            const factors = this.factor(n);
            const posN = this.getPosition(n);

            // Get all primes up to max(sqrt(n) * 2, largest_factor) to ensure both factors included
            const maxFactor = factors.length > 0 ? Math.max(...factors) : 0;
            const primeLimit = Math.min(Math.max(Math.sqrt(n) * 2, maxFactor), this.explorer.maxN);
            const primes = this.explorer.points.filter(p => p.isPrime && p.n <= primeLimit);

            // Compute distance to each prime
            const spectrum = [];
            for (const prime of primes) {
                const posPrime = { x: prime.x, y: prime.y, z: prime.z };
                const dist = this.distance(posN, posPrime);
                spectrum.push({
                    prime: prime.n,
                    distance: dist,
                    isFactor: factors.includes(prime.n)
                });
            }

            // Sort by prime value for plotting
            spectrum.sort((a, b) => a.prime - b.prime);

            // Statistics
            const factorDistances = spectrum.filter(s => s.isFactor && Number.isFinite(s.distance)).map(s => s.distance);
            const nonFactorDistances = spectrum.filter(s => !s.isFactor && Number.isFinite(s.distance)).map(s => s.distance);

            const avgFactorDist = factorDistances.length > 0 
                ? factorDistances.reduce((a, b) => a + b, 0) / factorDistances.length : 0;
            const avgNonFactorDist = nonFactorDistances.length > 0
                ? nonFactorDistances.reduce((a, b) => a + b, 0) / nonFactorDistances.length : 0;

            // Find rank of factors among all distances
            const validSpectrum = spectrum.filter(s => Number.isFinite(s.distance));
            const sortedByDist = [...validSpectrum].sort((a, b) => a.distance - b.distance);
            const factorRanks = factors.map(f => {
                const idx = sortedByDist.findIndex(s => s.prime === f);
                return { factor: f, rank: idx + 1, percentile: ((idx + 1) / validSpectrum.length * 100).toFixed(1) };
            });

            return {
                n,
                factors,
                spectrum,
                stats: {
                    totalPrimes: spectrum.length,
                    avgFactorDist: avgFactorDist.toFixed(4),
                    avgNonFactorDist: avgNonFactorDist.toFixed(4),
                    ratio: avgNonFactorDist > 0 ? (avgFactorDist / avgNonFactorDist).toFixed(3) : 'N/A',
                    factorRanks
                }
            };
        }

        // Run statistical test: Are factors closer than random?
        permutationTest(n, iterations = 500) {
            const result = this.computeSpectrum(n);
            if (result.factors.length === 0) return null;

            const observedAvg = parseFloat(result.stats.avgFactorDist);
            const numFactors = result.factors.length;

            // FIXED: Exclude actual factors from the pool of random candidates
            const nonFactorDistances = result.spectrum
                .filter(s => !s.isFactor)
                .map(s => s.distance)
                .filter(d => Number.isFinite(d));

            // Check how many factors are actually in the spectrum
            const factorsInSpectrum = result.spectrum.filter(s => s.isFactor).length;
            if (factorsInSpectrum < numFactors) {
                return {
                    n,
                    factors: result.factors,
                    observedAvgDist: observedAvg.toFixed(4),
                    pValue: 'N/A',
                    significant: false,
                    interpretation: `‚ö†Ô∏è Only ${factorsInSpectrum}/${numFactors} factors in analysis range`
                };
            }

            // If we don't have enough non-factors to sample, can't run test
            if (nonFactorDistances.length < numFactors) {
                return {
                    n,
                    factors: result.factors,
                    observedAvgDist: observedAvg.toFixed(4),
                    pValue: 'N/A',
                    significant: false,
                    interpretation: '‚ö†Ô∏è Not enough non-factors to run permutation test'
                };
            }

            let countLessOrEqual = 0;
            for (let i = 0; i < iterations; i++) {
                // Randomly pick numFactors distances FROM NON-FACTORS ONLY
                const shuffled = [...nonFactorDistances].sort(() => Math.random() - 0.5);
                const randomPick = shuffled.slice(0, numFactors);
                const randomAvg = randomPick.reduce((a, b) => a + b, 0) / numFactors;
                if (randomAvg <= observedAvg) countLessOrEqual++;
            }

            const pValue = countLessOrEqual / iterations;

            return {
                n,
                factors: result.factors,
                observedAvgDist: observedAvg.toFixed(4),
                pValue: pValue.toFixed(4),
                significant: pValue < 0.05,
                interpretation: pValue < 0.05 
                    ? '‚úÖ Factors are CLOSER than random!'
                    : '‚ùå No significant proximity effect'
            };
        }

        // Generate random semiprime for testing
        randomSemiprime(maxPrime = 500) {
            const primes = [];
            for (let i = 2; i <= maxPrime; i++) {
                if (PrimeMath.isPrime(i)) primes.push(i);
            }
            const p = primes[Math.floor(Math.random() * primes.length)];
            const q = primes[Math.floor(Math.random() * primes.length)];
            return p * q;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: NeighborhoodAnalyzer ‚Äî Are factors special in N's neighborhood?
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class NeighborhoodAnalyzer {
        constructor(explorer) {
            this.explorer = explorer;
            this.resonance = new ResonanceAnalyzer(explorer);
        }

        // Analyze neighborhood of N
        analyze(n, radius = 0.3) {
            const factors = this.resonance.factor(n);
            const posN = this.resonance.getPosition(n);

            // Find all primes within radius
            const neighbors = [];
            for (const point of this.explorer.points) {
                if (!point.isPrime) continue;
                const dist = this.resonance.distance(posN, { x: point.x, y: point.y, z: point.z });
                if (dist <= radius) {
                    neighbors.push({
                        prime: point.n,
                        distance: dist,
                        isFactor: factors.includes(point.n)
                    });
                }
            }

            // Sort by distance
            neighbors.sort((a, b) => a.distance - b.distance);

            // Check if factors are in neighborhood
            const factorsFound = factors.filter(f => neighbors.some(nb => nb.prime === f));
            const factorsInNeighborhood = factorsFound.length;

            // Factor positions within neighborhood
            const factorPositions = factors.map(f => {
                const idx = neighbors.findIndex(nb => nb.prime === f);
                return { factor: f, position: idx === -1 ? 'NOT IN NEIGHBORHOOD' : idx + 1 };
            });

            // Statistical: Expected vs observed
            const totalPrimesInRange = this.explorer.points.filter(p => p.isPrime && p.n <= Math.max(...factors) * 2).length;
            const expectedFactorsIfRandom = (neighbors.length / totalPrimesInRange) * factors.length;

            return {
                n,
                factors,
                radius,
                posN,
                neighbors,
                stats: {
                    totalNeighbors: neighbors.length,
                    factorsInNeighborhood,
                    factorPositions,
                    expectedIfRandom: expectedFactorsIfRandom.toFixed(2),
                    enrichment: factorsInNeighborhood > 0 
                        ? (factorsInNeighborhood / expectedFactorsIfRandom).toFixed(2) + 'x'
                        : '0x'
                }
            };
        }

        // Batch test across many semiprimes
        batchTest(count = 50, radius = 0.3) {
            const results = [];
            const primes = this.explorer.points.filter(p => p.isPrime && p.n < 500).map(p => p.n);

            for (let i = 0; i < count; i++) {
                const p = primes[Math.floor(Math.random() * primes.length)];
                const q = primes[Math.floor(Math.random() * primes.length)];
                const n = p * q;

                if (n > this.explorer.maxN) continue;

                const analysis = this.analyze(n, radius);
                results.push({
                    n,
                    factors: analysis.factors,
                    neighborsCount: analysis.stats.totalNeighbors,
                    factorsFound: analysis.stats.factorsInNeighborhood,
                    allFactorsFound: analysis.stats.factorsInNeighborhood === analysis.factors.length
                });
            }

            // Summary
            const successCount = results.filter(r => r.allFactorsFound).length;
            const partialCount = results.filter(r => r.factorsFound > 0 && !r.allFactorsFound).length;

            return {
                tested: results.length,
                allFactorsFound: successCount,
                someFactorsFound: partialCount,
                noFactorsFound: results.length - successCount - partialCount,
                successRate: (successCount / results.length * 100).toFixed(1) + '%',
                results
            };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: ConstraintVisualizer ‚Äî Shows how extra info shrinks search space
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class ConstraintVisualizer {
        constructor(explorer) {
            this.explorer = explorer;
            this.resonance = new ResonanceAnalyzer(explorer);
            this.highlightedPrimes = new Set();
        }

        // Get all candidate primes for a given constraint
        getCandidates(n, constraintType, strength) {
            const factors = this.resonance.factor(n);
            const p = factors[0];
            const q = factors.length > 1 ? factors[factors.length - 1] : p;
            const sqrtN = Math.sqrt(n);

            // All primes up to sqrt(N)
            const allPrimes = this.explorer.points.filter(pt => pt.isPrime && pt.n <= sqrtN).map(pt => pt.n);

            let candidates = [];
            let constraintDesc = '';

            switch (constraintType) {
                case 'none':
                    candidates = allPrimes;
                    constraintDesc = `No constraint: ${allPrimes.length} candidates`;
                    break;

                case 'topbits': {
                    // Strength = percentage of bits known (0-100)
                    const bits = Math.ceil(Math.log2(p));
                    const knownBits = Math.ceil(bits * strength / 100);
                    const mask = ((1 << knownBits) - 1) << (bits - knownBits);
                    const prefix = p & mask;

                    candidates = allPrimes.filter(prime => {
                        const primeBits = Math.ceil(Math.log2(prime));
                        if (primeBits !== bits) return false;
                        return (prime & mask) === prefix;
                    });
                    constraintDesc = `Top ${knownBits}/${bits} bits known: ${candidates.length} candidates`;
                    break;
                }

                case 'sum': {
                    // Strength = inverse of error range (100 = exact, 0 = huge range)
                    const sum = p + q;
                    const errorRange = Math.ceil((100 - strength) / 100 * sqrtN);

                    candidates = allPrimes.filter(prime => {
                        const complement = sum - prime;
                        return complement > 1 && Math.abs(n - prime * complement) <= errorRange * prime;
                    });
                    constraintDesc = `p+q known ¬± ${errorRange}: ${candidates.length} candidates`;
                    break;
                }

                case 'close': {
                    // Strength = how close (100 = identical, 0 = any)
                    const diff = Math.abs(p - q);
                    const maxDiff = Math.ceil((100 - strength) / 100 * sqrtN);
                    const center = Math.sqrt(n);

                    candidates = allPrimes.filter(prime => Math.abs(prime - center) <= maxDiff);
                    constraintDesc = `|p-q| < ${maxDiff}: ${candidates.length} candidates`;
                    break;
                }
            }

            // Calculate reduction
            const reduction = ((allPrimes.length - candidates.length) / allPrimes.length * 100).toFixed(1);

            return {
                n,
                factors,
                constraintType,
                strength,
                constraintDesc,
                allPrimesCount: allPrimes.length,
                candidatesCount: candidates.length,
                candidates,
                reduction: reduction + '% eliminated',
                factorsInCandidates: factors.filter(f => candidates.includes(f)).length === factors.length
            };
        }

        // Highlight candidates on visualization
        highlightCandidates(candidates) {
            this.highlightedPrimes = new Set(candidates);
        }

        clearHighlight() {
            this.highlightedPrimes.clear();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: ErrorVectorAnalyzer ‚Äî Structure in non-linearity
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class ErrorVectorAnalyzer {
        constructor(explorer) {
            this.explorer = explorer;
            this.resonance = new ResonanceAnalyzer(explorer);
            this.errorCache = [];
        }

        // Compute error vector for a single (p, q) pair
        computeError(p, q) {
            const n = p * q;

            const posP = this.resonance.getPosition(p);
            const posQ = this.resonance.getPosition(q);
            const posN = this.resonance.getPosition(n);

            // Linear prediction: Pos(p) + Pos(q)
            const predicted = {
                x: posP.x + posQ.x,
                y: posP.y + posQ.y,
                z: posP.z + posQ.z
            };

            // Error = Actual - Predicted
            const error = {
                x: posN.x - predicted.x,
                y: posN.y - predicted.y,
                z: posN.z - predicted.z
            };

            const errorMagnitude = Math.sqrt(error.x ** 2 + error.y ** 2 + error.z ** 2);

            return {
                p, q, n,
                posP, posQ, posN,
                predicted,
                error,
                errorMagnitude
            };
        }

        // Compute errors for many pairs
        batchCompute(sampleSize = 200) {
            const primes = this.explorer.points.filter(pt => pt.isPrime && pt.n < 500).map(pt => pt.n);
            const results = [];

            for (let i = 0; i < sampleSize; i++) {
                const p = primes[Math.floor(Math.random() * primes.length)];
                const q = primes[Math.floor(Math.random() * primes.length)];

                if (p * q > this.explorer.maxN * 2) continue;

                const error = this.computeError(p, q);
                results.push(error);
            }

            this.errorCache = results;
            return results;
        }

        // Analyze correlations in error vectors
        analyzeCorrelations() {
            if (this.errorCache.length === 0) {
                this.batchCompute(200);
            }

            const errors = this.errorCache;

            // Correlation: error magnitude vs various properties
            const correlations = {};

            // 1. Error vs product size
            const nValues = errors.map(e => e.n);
            const magValues = errors.map(e => e.errorMagnitude);
            correlations.vsProductSize = this.pearsonCorrelation(nValues, magValues);

            // 2. Error vs factor ratio (p/q)
            const ratios = errors.map(e => Math.max(e.p, e.q) / Math.min(e.p, e.q));
            correlations.vsFactorRatio = this.pearsonCorrelation(ratios, magValues);

            // 3. Error vs factor sum
            const sums = errors.map(e => e.p + e.q);
            correlations.vsFactorSum = this.pearsonCorrelation(sums, magValues);

            // 4. Error vs factor difference
            const diffs = errors.map(e => Math.abs(e.p - e.q));
            correlations.vsFactorDiff = this.pearsonCorrelation(diffs, magValues);

            // Statistics
            const avgError = magValues.reduce((a, b) => a + b, 0) / magValues.length;
            const maxError = Math.max(...magValues);
            const minError = Math.min(...magValues);

            return {
                sampleSize: errors.length,
                avgError: avgError.toFixed(4),
                minError: minError.toFixed(4),
                maxError: maxError.toFixed(4),
                correlations: {
                    productSize: { r: correlations.vsProductSize.toFixed(3), meaning: 'Error vs N' },
                    factorRatio: { r: correlations.vsFactorRatio.toFixed(3), meaning: 'Error vs max(p,q)/min(p,q)' },
                    factorSum: { r: correlations.vsFactorSum.toFixed(3), meaning: 'Error vs p+q' },
                    factorDiff: { r: correlations.vsFactorDiff.toFixed(3), meaning: 'Error vs |p-q|' }
                },
                strongestCorrelation: this.findStrongest(correlations)
            };
        }

        // Pearson correlation coefficient
        pearsonCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0);
            const sumY2 = y.reduce((a, b) => a + b * b, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX ** 2) * (n * sumY2 - sumY ** 2));

            return denominator === 0 ? 0 : numerator / denominator;
        }

        findStrongest(correlations) {
            const entries = Object.entries(correlations);
            let strongest = { key: '', value: 0 };
            for (const [key, value] of entries) {
                if (Math.abs(value) > Math.abs(strongest.value)) {
                    strongest = { key, value };
                }
            }
            return strongest;
        }

        // Get data for plotting
        getPlotData() {
            if (this.errorCache.length === 0) {
                this.batchCompute(200);
            }

            return this.errorCache.map(e => ({
                x: e.n,
                y: e.errorMagnitude,
                p: e.p,
                q: e.q,
                ratio: Math.max(e.p, e.q) / Math.min(e.p, e.q)
            }));
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EC MODE CLASSES ‚Äî Elliptic Curve Analysis for BSD + Factorization Research
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class EllipticCurveData {
        constructor(label, conductor, rank, sha, torsion, a_p_data, bsdData = null) {
            this.label = label;
            this.conductor = conductor;
            this.rank = rank;
            this.sha = sha;
            this.torsion = torsion;
            this.a_p = new Map(Object.entries(a_p_data).map(([k, v]) => [parseInt(k), v]));
            // BSD formula components (optional)
            this.bsd = bsdData || { omega: null, regulator: null, tamagawa: null, lValue: null, lDerivative: null };
        }

        reductionType(p) {
            if (this.conductor % p === 0) return 'bad';
            const ap = this.a_p.get(p);
            if (ap === undefined) return 'unknown';
            if (ap === 0) return 'supersingular';
            return 'ordinary';
        }

        // Compute partial L-function product at s=1
        partialLValue(primeLimit = 100) {
            let product = 1.0;
            const contributions = [];
            for (const [p, a_p] of this.a_p) {
                if (p > primeLimit) break;
                if (this.conductor % p === 0) continue;
                const factor = 1.0 / (1 - a_p / p + 1 / p);
                product *= factor;
                contributions.push({ p, a_p, factor: factor.toFixed(6), cumulative: product.toFixed(6) });
            }
            return { product, contributions };
        }

        // Verify BSD formula numerically
        verifyBSD() {
            if (!this.bsd || !this.bsd.omega) return { error: 'Missing BSD data' };
            const leftSide = this.rank === 0 ? this.bsd.lValue : this.bsd.lDerivative;
            if (!leftSide) return { error: 'Missing L-value data' };
            const rightSide = (this.sha * this.bsd.omega * this.bsd.regulator * this.bsd.tamagawa) / (this.torsion * this.torsion);
            const error = Math.abs(leftSide - rightSide);
            const relError = error / leftSide;
            return {
                leftSide: leftSide.toFixed(10), rightSide: rightSide.toFixed(10),
                absoluteError: error.toExponential(3), relativeError: (relError * 100).toFixed(6) + '%',
                verified: relError < 1e-4,
                formula: this.rank === 0 ? 'L(E,1) = Sha √ó Œ© √ó Reg √ó Tam / Tor¬≤' : `L^(${this.rank})(E,1)/${this.rank}! = Sha √ó Œ© √ó Reg √ó Tam / Tor¬≤`,
                components: { sha: this.sha, omega: this.bsd.omega, regulator: this.bsd.regulator, tamagawa: this.bsd.tamagawa, torsion: this.torsion }
            };
        }

        // Explain Sha structure (why it's a square, what it means)
        getShaStructure() {
            if (this.sha === 1) return { order: 1, structure: 'Trivial', elements: ['identity'], explanation: 'Sha is trivial ‚Äî Hasse principle holds.' };
            const sqrtSha = Math.sqrt(this.sha);
            if (!Number.isInteger(sqrtSha)) return { error: 'Sha is not a perfect square ‚Äî data error!' };
            const factorize = (n) => { const f = []; let t = n; for (let p = 2; p * p <= t; p++) { while (t % p === 0) { f.push(p); t /= p; } } if (t > 1) f.push(t); return f; };
            const factors = factorize(sqrtSha);
            const primeCounts = {}; for (const p of factors) primeCounts[p] = (primeCounts[p] || 0) + 1;
            const structureParts = []; for (const [p, count] of Object.entries(primeCounts)) structureParts.push(`(‚Ñ§/${p}‚Ñ§)^${count * 2}`);
            return {
                order: this.sha, sqrtOrder: sqrtSha, structure: structureParts.join(' √ó '), primeFactors: Object.keys(primeCounts).map(Number),
                elementCount: this.sha, nonTrivialElements: this.sha - 1, nonTrivialPairs: (this.sha - 1) / 2,
                explanation: this.sha === 9
                    ? 'Sha ‚âÖ (‚Ñ§/3‚Ñ§)¬≤ ‚Äî a 2-dimensional vector space over F‚ÇÉ.\nContains 9 elements: 1 identity + 8 non-trivial (4 pairs {x, -x}).\nEach non-trivial element is a genus-1 curve that has local points but NO rational points!'
                    : `Sha ‚âÖ ${structureParts.join(' √ó ')} with ${this.sha} elements.`,
                casselsPairing: "Cassels' theorem: The Cassels-Tate pairing –® √ó –® ‚Üí ‚Ñö/‚Ñ§ is alternating, forcing |–®| to be a perfect square when finite."
            };
        }

        getColor(p) {
            switch (this.reductionType(p)) {
                case 'bad': return { r: 255, g: 80, b: 80 };
                case 'supersingular': return { r: 80, g: 150, b: 255 };
                case 'ordinary': return { r: 255, g: 220, b: 80 };
                case 'unknown': return { r: 100, g: 100, b: 100 };
                default: return { r: 128, g: 128, b: 128 };
            }
        }

        isShaTestCandidate(p) {
            if (!this.sha || this.sha === 1) return false;
            if (this.sha % p !== 0) return false;
            return this.reductionType(p) === 'supersingular';
        }

        getSupersingularPrimes(limit = 1000) {
            const ss = [];
            for (const [p, ap] of this.a_p) {
                if (p <= limit && ap === 0 && this.conductor % p !== 0) ss.push(p);
            }
            return ss.sort((a, b) => a - b);
        }

        getBadPrimes() {
            const bad = [];
            let n = this.conductor;
            for (let p = 2; p * p <= n; p++) {
                if (n % p === 0) { bad.push(p); while (n % p === 0) n /= p; }
            }
            if (n > 1) bad.push(n);
            return bad;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CURVE DATABASE ‚Äî With verified LMFDB data and full BSD components
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const CURVE_DATABASE = {
        // 182d1 ‚Äî THE verified Sha=9 curve for BSD pedagogy (from LMFDB)
        // y¬≤ + xy = x¬≥ - 15663x - 755809, Conductor 182 = 2¬∑7¬∑13
        "182d1": new EllipticCurveData("182.d1", 182, 0, 9, 1, {
            2: 0, 3: -1, 5: 2, 7: 0, 11: -4, 13: 0, 17: 2, 19: 4,
            23: 0, 29: -6, 31: 4, 37: 2, 41: 6, 43: 8, 47: 0,
            53: -6, 59: -4, 61: -10, 67: 8, 71: 0, 73: 6, 79: -8,
            83: 12, 89: 2, 97: -14, 101: -6, 103: 0, 107: -12, 109: 2,
            113: 6, 127: 8, 131: -10, 137: -6, 139: 8, 149: 2, 151: -4
        }, { omega: 0.213378509729, regulator: 1.0, tamagawa: 1, lValue: 1.920406588, lDerivative: null }),

        // 37a1 ‚Äî Classic rank 1 curve (first interesting curve in Cremona tables)
        "37a1": new EllipticCurveData("37a1", 37, 1, 1, 1, {
            2: -2, 3: -3, 5: -2, 7: -2, 11: -2, 13: 6, 17: 0, 19: 0,
            23: -4, 29: 2, 31: 8, 41: -10, 43: 2, 47: 8, 53: -6, 59: -4,
            61: -4, 67: -10, 71: -4, 73: -6, 79: -12, 83: -6, 89: 8, 97: -12,
            101: -2, 103: 16, 107: 4, 109: 2, 113: -6, 127: 8, 131: -10,
            137: -6, 139: 8, 149: 2, 151: -4, 157: -10, 163: -2, 167: 12,
            173: 2, 179: 8, 181: -10, 191: 0, 193: 2, 197: 2, 199: -16
        }, { omega: 5.98691729246, regulator: 0.0511114082, tamagawa: 1, lValue: null, lDerivative: 0.305999773 }),

        // 389a1 ‚Äî First rank 2 curve
        "389a1": new EllipticCurveData("389a1", 389, 2, 1, 1, {
            2: -2, 3: -3, 5: -3, 7: -5, 11: -5, 13: 2, 17: 0, 19: -1,
            23: 4, 29: -6, 31: -4, 37: 3, 41: 9, 43: -6, 47: -7,
            53: -6, 59: 5, 61: 12, 67: -7, 71: -1, 73: -4, 79: 5,
            83: -6, 89: 10, 97: -1, 101: 5, 103: -13, 107: 0, 109: -4,
            113: 3, 127: -16, 131: 15, 137: 6, 139: -4, 149: -6, 151: -13,
            157: -4, 163: -10, 167: 0, 173: 18, 179: 0, 181: -4, 191: -7
        }, { omega: 2.2831089764, regulator: 0.1523840078, tamagawa: 1, lValue: null, lDerivative: 0.3479604288 }),

        // 5077a1 ‚Äî First rank 3 curve
        "5077a1": new EllipticCurveData("5077a1", 5077, 3, 1, 1, {
            2: 1, 3: -1, 5: -1, 7: -3, 11: -4, 13: 2, 17: 0, 19: 4,
            23: 4, 29: 2, 31: -4, 37: -6, 41: 6, 43: 8, 47: -8,
            53: -6, 59: 4, 61: 2, 67: -4, 71: 0, 73: -6, 79: 0,
            83: 4, 89: -6, 97: 2, 101: 6, 103: 8, 107: 4, 109: -10
        }, { omega: 5.09531, regulator: 0.41714, tamagawa: 1, lValue: null, lDerivative: 2.127 }),

        // 11a1 ‚Äî Non-trivial torsion example (‚Ñ§/5‚Ñ§)
        "11a1": new EllipticCurveData("11a1", 11, 0, 1, 5, {
            2: -2, 3: -1, 5: 1, 7: -2, 13: 4, 17: -2, 19: 0, 23: -1,
            29: 0, 31: 7, 37: 3, 41: -8, 43: -6, 47: 8, 53: -6, 59: 5,
            61: 12, 67: -7, 71: -3, 73: 4, 79: -10, 83: -6, 89: 10,
            97: -7, 101: 2, 103: 17, 107: 0, 109: 2, 113: 6, 127: -13
        }, { omega: 1.26920930, regulator: 1.0, tamagawa: 1, lValue: 0.253842, lDerivative: null }),

        // Keep 681b1 for backward compatibility but note it's actually rank 1
        "681b1": new EllipticCurveData("681b1", 681, 1, 1, 1, {
            2: -1, 5: -3, 7: 0, 11: -2, 13: 6, 17: -2, 19: -4, 23: 0,
            29: 2, 31: 4, 37: -6, 41: 2, 43: -2, 47: 8, 53: 6, 59: 4,
            61: -10, 67: -2, 71: -8, 73: 6, 79: 8, 83: -6, 89: -10,
            97: -6, 101: -2, 103: 16, 107: 4, 109: 2, 113: 14, 127: -8
        }, { omega: 3.8079, regulator: 0.2252, tamagawa: 2, lValue: null, lDerivative: 1.7148 }),

        // 433a1 ‚Äî Another rank 1 curve
        "433a1": new EllipticCurveData("433a1", 433, 1, 1, 1, {
            2: -1, 3: 0, 5: 1, 7: -3, 11: 4, 13: -1, 17: 6, 19: 0,
            23: 0, 29: -6, 31: -4, 37: 2, 41: -6, 43: 8, 47: 0,
            53: 6, 59: -4, 61: -10, 67: 8, 71: 0, 73: -10, 79: 8,
            83: -6, 89: 10, 97: -14, 101: 2, 103: 0, 107: 12, 109: -10
        }, null)
    };

    class ECModeAnalyzer {
        constructor(explorer) {
            this.explorer = explorer;
            this.enabled = false;
            this.currentCurve = null;
            this.filter = 'none';
        }

        setCurve(label) {
            this.currentCurve = CURVE_DATABASE[label] || null;
            return this.currentCurve;
        }

        getColor(p) {
            if (!this.enabled || !this.currentCurve) return null;
            if (!PrimeMath.isPrime(p)) return null;
            return this.currentCurve.getColor(p);
        }

        shouldShow(n) {
            if (!this.enabled || !this.currentCurve) return true;
            if (!PrimeMath.isPrime(n)) return true;
            switch (this.filter) {
                case 'supersingular': return this.currentCurve.reductionType(n) === 'supersingular';
                case 'bad': return this.currentCurve.reductionType(n) === 'bad';
                case 'shaTest': return this.currentCurve.isShaTestCandidate(n);
                default: return true;
            }
        }

        getStatistics(maxN) {
            if (!this.currentCurve) return null;
            const stats = {
                curve: this.currentCurve.label,
                conductor: this.currentCurve.conductor,
                rank: this.currentCurve.rank,
                sha: this.currentCurve.sha,
                torsion: this.currentCurve.torsion,
                badPrimes: this.currentCurve.getBadPrimes(),
                supersingular: [], ordinary: [], shaTestCandidates: []
            };
            for (let p = 2; p <= maxN; p++) {
                if (!PrimeMath.isPrime(p)) continue;
                const type = this.currentCurve.reductionType(p);
                if (type === 'supersingular') stats.supersingular.push(p);
                else if (type === 'ordinary') stats.ordinary.push(p);
                if (this.currentCurve.isShaTestCandidate(p)) stats.shaTestCandidates.push(p);
            }
            return stats;
        }

        compareCurves(labels, maxN) {
            const curves = labels.map(l => CURVE_DATABASE[l]).filter(c => c);
            if (curves.length < 2) return null;
            const results = { curves: labels, commonSS: [], neverSS: [], distribution: {} };
            for (let p = 2; p <= maxN; p++) {
                if (!PrimeMath.isPrime(p)) continue;
                const types = curves.map(c => c.reductionType(p));
                if (types.every(t => t === 'supersingular')) results.commonSS.push(p);
                if (types.every(t => t !== 'supersingular')) results.neverSS.push(p);
            }
            return results;
        }

        getBSDInfo() {
            if (!this.currentCurve) return '';
            const c = this.currentCurve;
            const badStr = c.getBadPrimes().join(', ') || 'none';
            const ssCount = this.getStatistics(500)?.supersingular.length || 0;
            let shaNote = '';
            if (c.sha > 1) {
                const shaPrimes = [];
                for (let p = 2; p * p <= c.sha; p++) if (c.sha % p === 0) shaPrimes.push(p);
                if (c.sha > 1 && PrimeMath.isPrime(c.sha)) shaPrimes.push(c.sha);
                const badSet = new Set(c.getBadPrimes());
                const shaTestable = shaPrimes.filter(p => !badSet.has(p) && c.reductionType(p) === 'supersingular');
                shaNote = shaTestable.length === 0
                    ? `<div style="color:#ff6b6b;margin-top:4px;">‚ö†Ô∏è No Sha test cases: primes dividing Sha=${c.sha} have bad reduction!</div>`
                    : `<div style="color:#00ff88;margin-top:4px;">‚úì Sha test candidates: ${shaTestable.join(', ')}</div>`;
            }
            return `<div><strong>Curve:</strong> ${c.label}</div>
                <div><strong>Conductor:</strong> ${c.conductor}</div>
                <div><strong>Rank:</strong> ${c.rank}</div>
                <div><strong>Sha:</strong> ${c.sha || '?'}</div>
                <div><strong>Torsion:</strong> ‚Ñ§/${c.torsion}‚Ñ§</div>
                <hr style="border-color:#333;margin:6px 0;">
                <div><strong>Bad primes:</strong> <span style="color:#ff6b6b;">${badStr}</span></div>
                <div><strong>Supersingular (p<500):</strong> <span style="color:#80a0ff;">${ssCount}</span></div>
                ${shaNote}`;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: BSDVisualizer ‚Äî Interactive BSD formula display and L-function animation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class BSDVisualizer {
        constructor(explorer) {
            this.explorer = explorer;
            this.currentCurve = null;
            this.animationFrame = null;
            this.lBuildupData = [];
        }

        setCurve(label) {
            this.currentCurve = CURVE_DATABASE[label] || null;
            return this.currentCurve;
        }

        // Generate HTML for BSD formula display
        getFormulaHTML() {
            if (!this.currentCurve) return '<div style="color:#888;">Select a curve with BSD data</div>';
            const c = this.currentCurve;
            const verification = c.verifyBSD();
            if (verification.error) return `<div style="color:#ff6b6b;">${verification.error}</div>`;

            const rank = c.rank;
            const lSymbol = rank === 0 ? 'L(E,1)' : `L<sup>(${rank})</sup>(E,1)/${rank}!`;

            return `
            <div class="bsd-container">
                <div class="bsd-title">BSD Formula: ${c.label}</div>
                <div class="bsd-equation">
                    <div class="bsd-left">
                        <span class="bsd-symbol">${lSymbol}</span>
                        <span class="bsd-value">${verification.leftSide}</span>
                    </div>
                    <span class="bsd-equals">=</span>
                    <div class="bsd-right">
                        <div class="bsd-fraction">
                            <div class="bsd-numerator">
                                <span class="bsd-term sha" title="Tate-Shafarevich group">Sha</span> √ó
                                <span class="bsd-term omega" title="Real period">Œ©</span> √ó
                                <span class="bsd-term reg" title="Regulator">Reg</span> √ó
                                <span class="bsd-term tam" title="Tamagawa">‚àèc</span>
                            </div>
                            <div class="bsd-denominator">
                                <span class="bsd-term tors" title="Torsion squared">|Tor|¬≤</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bsd-values">
                    <div class="bsd-row"><span class="bsd-label sha">Sha=</span><span class="bsd-number sha-highlight">${c.sha}</span></div>
                    <div class="bsd-row"><span class="bsd-label omega">Œ©=</span><span class="bsd-number">${c.bsd.omega?.toFixed(4) || '?'}</span></div>
                    <div class="bsd-row"><span class="bsd-label reg">Reg=</span><span class="bsd-number">${c.bsd.regulator?.toFixed(4) || '?'}</span></div>
                    <div class="bsd-row"><span class="bsd-label tam">‚àèc=</span><span class="bsd-number">${c.bsd.tamagawa || '?'}</span></div>
                    <div class="bsd-row"><span class="bsd-label tors">|Tor|=</span><span class="bsd-number">${c.torsion}</span></div>
                    <div class="bsd-row"><span class="bsd-label">Rank=</span><span class="bsd-number">${c.rank}</span></div>
                </div>
                <div class="bsd-calculation">
                    ${c.sha} √ó ${c.bsd.omega?.toFixed(4) || '?'} √ó ${c.bsd.regulator?.toFixed(4) || '?'} √ó ${c.bsd.tamagawa || '?'} / ${c.torsion}¬≤ = ${verification.rightSide}
                </div>
                <div class="bsd-verification ${verification.verified ? 'success' : 'warning'}">
                    ${verification.verified ? '‚úì BSD Verified!' : '‚ö† ' + verification.relativeError + ' error'}
                </div>
            </div>`;
        }

        // Generate HTML for Sha structure explanation
        getShaExplanationHTML() {
            if (!this.currentCurve) return '';
            const shaStruct = this.currentCurve.getShaStructure();
            if (shaStruct.error) return `<div style="color:#ff6b6b;">${shaStruct.error}</div>`;
            if (shaStruct.order === 1) return '<div class="sha-container"><div class="sha-title">Sha Structure</div><div style="color:#00ff88;">Sha = 1 (trivial)</div></div>';

            return `
            <div class="sha-container">
                <div class="sha-title">Tate-Shafarevich Structure</div>
                <div class="sha-main">
                    <div class="sha-order">|–®| = ${shaStruct.order} = ${shaStruct.sqrtOrder}¬≤</div>
                    <div class="sha-structure">–® ‚âÖ ${shaStruct.structure}</div>
                </div>
                <div class="sha-elements">
                    <div>${shaStruct.elementCount} elements: 1 identity + ${shaStruct.nonTrivialElements} non-trivial</div>
                    <ul>
                        <li>${shaStruct.nonTrivialPairs} pairs {x, ‚àíx}</li>
                        <li>Each represents a genus-1 curve with local but no global points</li>
                    </ul>
                </div>
                <div class="sha-explanation">${shaStruct.explanation.replace(/\n/g, '<br>')}</div>
                <div class="sha-cassels">
                    <div class="sha-cassels-title">Cassels' Theorem</div>
                    <p>${shaStruct.casselsPairing}</p>
                </div>
            </div>`;
        }

        // Generate L-function buildup data
        getLFunctionBuildupData(maxPrimes = 30) {
            if (!this.currentCurve) return null;
            const { product, contributions } = this.currentCurve.partialLValue(maxPrimes * 10);
            return {
                curve: this.currentCurve.label,
                targetValue: this.currentCurve.bsd.lValue || this.currentCurve.bsd.lDerivative,
                partialProduct: product,
                convergence: contributions.slice(0, maxPrimes)
            };
        }

        // Render L-function buildup visualization
        renderLFunctionBuildup(containerId, animate = false) {
            const container = document.getElementById(containerId);
            if (!container || !this.currentCurve) return;

            const data = this.getLFunctionBuildupData(25);
            if (!data) return;

            const bars = data.convergence.map((c, i) => {
                const factor = parseFloat(c.factor);
                const height = Math.min(Math.abs(factor - 1) * 150, 35);
                const color = factor > 1 ? '#ff6b6b' : '#4ecdc4';
                const delay = animate ? `animation-delay: ${i * 80}ms;` : '';
                return `<div class="l-bar ${animate ? 'animating' : ''}" style="height:${height}px;background:${color};--target-height:${height}px;${delay}" title="p=${c.p}, a_p=${c.a_p}"><span class="l-prime">${c.p}</span></div>`;
            }).join('');

            container.innerHTML = `
            <div class="l-function-buildup">
                <div class="l-title">L-function Euler Product</div>
                <div class="l-formula">L(E,s) = ‚àè (1 - a<sub>p</sub>p<sup>-s</sup> + p<sup>1-2s</sup>)<sup>-1</sup></div>
                <div class="l-bars-container">
                    <div class="l-bars">${bars}</div>
                    <div class="l-baseline"></div>
                </div>
                <div class="l-legend">
                    <span class="l-legend-up">‚Üë Increases L</span>
                    <span class="l-legend-down">‚Üì Decreases L</span>
                </div>
                <div class="l-result">
                    Partial (${data.convergence.length} primes): <span class="l-value">${data.partialProduct.toFixed(6)}</span>
                    ${data.targetValue ? `<span class="l-target">Target: ${data.targetValue.toFixed(6)}</span>` : ''}
                </div>
            </div>`;
        }

        // Color primes by L-function contribution
        getLContributionColor(p) {
            if (!this.currentCurve) return null;
            const a_p = this.currentCurve.a_p.get(p);
            if (a_p === undefined) return { r: 100, g: 100, b: 100 };
            const factor = 1.0 / (1 - a_p / p + 1 / p);
            if (factor > 1.05) {
                const intensity = Math.min((factor - 1) * 5, 1);
                return { r: 255, g: Math.floor(200 - 150 * intensity), b: Math.floor(100 - 50 * intensity) };
            } else if (factor < 0.95) {
                const intensity = Math.min((1 - factor) * 5, 1);
                return { r: Math.floor(100 - 50 * intensity), g: Math.floor(200 - 100 * intensity), b: 255 };
            }
            return { r: 200, g: 200, b: 200 };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ADVANCED L-FUNCTION ANIMATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Initialize step-by-step animation state
        initAnimation(containerId) {
            if (!this.currentCurve) return false;
            this.animState = {
                containerId,
                step: 0,
                maxSteps: 30,
                product: 1.0,
                data: this.getLFunctionBuildupData(35),
                running: false,
                interval: null
            };
            return true;
        }

        // Run animated buildup with step-by-step progression
        runAnimation(speed = 200, onStep = null) {
            if (!this.animState || !this.animState.data) return;
            this.animState.running = true;
            this.animState.step = 0;
            this.animState.product = 1.0;

            const container = document.getElementById(this.animState.containerId);
            if (!container) return;

            const data = this.animState.data;
            const target = data.targetValue;

            // Initial render
            this._renderAnimationFrame(container, data, target);

            // Animation loop
            this.animState.interval = setInterval(() => {
                if (this.animState.step >= data.convergence.length) {
                    this.stopAnimation();
                    if (onStep) onStep({ done: true, product: this.animState.product, target });
                    return;
                }

                const contrib = data.convergence[this.animState.step];
                const factor = parseFloat(contrib.factor);
                this.animState.product *= factor;
                this.animState.step++;

                this._renderAnimationFrame(container, data, target);

                if (onStep) {
                    onStep({
                        step: this.animState.step,
                        prime: contrib.p,
                        a_p: contrib.a_p,
                        factor: factor,
                        product: this.animState.product,
                        target: target,
                        convergence: target ? Math.abs(this.animState.product - target) / target : null
                    });
                }
            }, speed);
        }

        // Stop animation
        stopAnimation() {
            if (this.animState && this.animState.interval) {
                clearInterval(this.animState.interval);
                this.animState.running = false;
            }
        }

        // Render a single animation frame
        _renderAnimationFrame(container, data, target) {
            const currentStep = this.animState.step;
            const bars = data.convergence.slice(0, Math.min(currentStep + 5, 30)).map((c, i) => {
                const factor = parseFloat(c.factor);
                const height = Math.min(Math.abs(factor - 1) * 150, 35);
                const color = factor > 1 ? '#ff6b6b' : '#4ecdc4';
                const active = i < currentStep;
                const current = i === currentStep;
                const opacity = active ? 1 : (current ? 0.7 : 0.2);
                const scale = current ? 'transform:scaleY(1.2);' : '';
                return `<div class="l-bar" style="height:${height}px;background:${color};opacity:${opacity};${scale}transition:all 0.15s;" title="p=${c.p}, a_p=${c.a_p}"><span class="l-prime">${c.p}</span></div>`;
            }).join('');

            const convergenceInfo = target && currentStep > 0
                ? `<div style="margin-top:4px;font-size:0.5rem;color:#888;">Convergence: ${((Math.abs(this.animState.product - target) / target) * 100).toFixed(2)}% from target</div>`
                : '';

            container.innerHTML = `
            <div class="l-function-buildup">
                <div class="l-title">L-function Buildup ‚Äî Step ${currentStep}/${data.convergence.length}</div>
                <div class="l-formula">L(E,s) = ‚àè<sub>p‚â§${data.convergence[Math.min(currentStep, data.convergence.length - 1)]?.p || '?'}</sub> (Euler factors)</div>
                <div class="l-bars-container">
                    <div class="l-bars">${bars}</div>
                    <div class="l-baseline"></div>
                </div>
                <div class="l-legend">
                    <span class="l-legend-up">‚Üë Increases L</span>
                    <span class="l-legend-down">‚Üì Decreases L</span>
                </div>
                <div class="l-result">
                    <div>Current: <span class="l-value" style="font-size:0.7rem;">${this.animState.product.toFixed(8)}</span></div>
                    ${target ? `<div>Target: <span class="l-target">${target.toFixed(8)}</span></div>` : ''}
                    ${convergenceInfo}
                </div>
            </div>`;
        }

        // Get interpretation text for L-function buildup
        getInterpretation() {
            if (!this.currentCurve) return '';
            const c = this.currentCurve;
            if (c.rank === 0) {
                return `For rank 0 curves, L(E,1) ‚â† 0. The partial product converges to L(E,1) = ${c.bsd.lValue?.toFixed(6) || '?'}, which equals Sha √ó Œ© √ó ... / Tor¬≤ via BSD.`;
            } else {
                return `For rank ${c.rank} curves, L(E,1) = 0 (zero of order ${c.rank}). The partial product oscillates around 0. The interesting quantity is L^(${c.rank})(E,1)/${c.rank}!.`;
            }
        }
    }

    class SemiprimeECAnalyzer {
        constructor(explorer) { this.explorer = explorer; this.results = []; }

        computeA_n(curve, n, p, q) {
            const a_p = curve.a_p.get(p), a_q = curve.a_p.get(q);
            if (a_p === undefined || a_q === undefined) return { a_n: null, method: 'missing_data' };
            const E_p = p + 1 - a_p, E_q = q + 1 - a_q, E_n = E_p * E_q, a_n = n + 1 - E_n;
            return { a_n, a_p, a_q, E_p, E_q, E_n, method: 'crt' };
        }

        testAdditivity(curve, n, p, q) {
            const result = this.computeA_n(curve, n, p, q);
            if (result.a_n === null) return { error: 'missing_data', n, p, q, curve: curve.label };
            const sum = result.a_p + result.a_q, product = result.a_p * result.a_q;
            const errorSum = Math.abs(result.a_n - sum), errorProduct = Math.abs(result.a_n - product);
            const scale = Math.max(Math.abs(result.a_n), 1);
            return { n, p, q, curve: curve.label, a_p: result.a_p, a_q: result.a_q, a_n: result.a_n,
                sum, product, errorSum, errorProduct, relErrorSum: errorSum / scale, relErrorProduct: errorProduct / scale,
                betterModel: errorSum / scale < errorProduct / scale ? 'additive' : 'multiplicative' };
        }

        batchTest(curve, maxPrime = 100, sampleSize = 50) {
            const primes = [];
            for (let i = 2; i <= maxPrime; i++) if (PrimeMath.isPrime(i) && curve.a_p.has(i)) primes.push(i);
            const results = [], tested = new Set();
            for (let i = 0; i < Math.min(sampleSize, primes.length * primes.length); i++) {
                const p = primes[Math.floor(Math.random() * primes.length)];
                const q = primes[Math.floor(Math.random() * primes.length)];
                const key = `${Math.min(p,q)}_${Math.max(p,q)}`;
                if (tested.has(key)) continue;
                tested.add(key);
                const result = this.testAdditivity(curve, p * q, p, q);
                if (!result.error) results.push(result);
            }
            this.results = results;
            return this.analyzeResults(results);
        }

        analyzeResults(results) {
            if (results.length === 0) return null;
            const avgErrorSum = results.reduce((s, r) => s + r.relErrorSum, 0) / results.length;
            const avgErrorProduct = results.reduce((s, r) => s + r.relErrorProduct, 0) / results.length;
            const additiveWins = results.filter(r => r.betterModel === 'additive').length;
            // FIX: Use relative error to avoid scaling artifact from Hasse bound
            const sums = results.map(r => r.p + r.q), errors = results.map(r => r.relErrorSum);
            const correlation = this.pearsonCorrelation(sums, errors);
            return { sampleSize: results.length, avgRelErrorSum: avgErrorSum.toFixed(4), avgRelErrorProduct: avgErrorProduct.toFixed(4),
                additiveWins, multiplicativeWins: results.length - additiveWins,
                dominantModel: additiveWins > results.length - additiveWins ? 'ADDITIVE' : 'MULTIPLICATIVE',
                correlationWithSum: correlation.toFixed(4),
                interpretation: Math.abs(correlation) > 0.3 ? '‚ö†Ô∏è Correlation with p+q ‚Äî investigate!' : '‚ùå No correlation ‚Äî EC properties don\'t reveal p+q' };
        }

        pearsonCorrelation(x, y) {
            const n = x.length; if (n === 0) return 0;
            const sumX = x.reduce((a, b) => a + b, 0), sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0), sumY2 = y.reduce((a, b) => a + b * b, 0);
            const num = n * sumXY - sumX * sumY, den = Math.sqrt((n * sumX2 - sumX ** 2) * (n * sumY2 - sumY ** 2));
            return den === 0 ? 0 : num / den;
        }

        findRevealingCurves(n, p, q) {
            const revealing = [];
            for (const label of Object.keys(CURVE_DATABASE)) {
                const curve = CURVE_DATABASE[label];
                const result = this.testAdditivity(curve, n, p, q);
                if (result.error) continue;
                if (result.relErrorSum < 0.1 || result.relErrorProduct < 0.1) {
                    revealing.push({ curve: label, relErrorSum: result.relErrorSum, relErrorProduct: result.relErrorProduct, a_n: result.a_n, a_p: result.a_p, a_q: result.a_q });
                }
            }
            return revealing.sort((a, b) => a.relErrorSum - b.relErrorSum);
        }
    }

    class GroupStructureAnalyzer {
        constructor(explorer) { this.explorer = explorer; this.orderCache = new Map(); }
        gcd(a, b) { while (b !== 0) [a, b] = [b, a % b]; return a; }
        lcm(a, b) { return (a * b) / this.gcd(a, b); }
        phi(n) { let result = n; for (let p = 2; p * p <= n; p++) { if (n % p === 0) { while (n % p === 0) n /= p; result -= result / p; } } if (n > 1) result -= result / n; return result; }
        multiplicativeOrder(x, n) {
            if (this.gcd(x, n) !== 1) return -1;
            const key = `${x}_${n}`; if (this.orderCache.has(key)) return this.orderCache.get(key);
            const phiN = this.phi(n); let order = 1, power = x % n;
            while (power !== 1 && order <= phiN) { power = (power * x) % n; order++; }
            this.orderCache.set(key, order); return order;
        }
        detectProductStructure(n) {
            const factors = PrimeMath.factorize(n);
            if (factors.length !== 2) return { error: 'Not a semiprime' };
            const p = factors[0], q = factors[1];
            const analysis = { n, p, q, phiP: p - 1, phiQ: q - 1, phiN: (p - 1) * (q - 1), elements: [] };
            for (let x = 2; x < Math.min(n, 100); x++) {
                if (this.gcd(x, n) !== 1) continue;
                const ordN = this.multiplicativeOrder(x, n), ordP = this.multiplicativeOrder(x % p, p), ordQ = this.multiplicativeOrder(x % q, q);
                analysis.elements.push({ x, ordN, ordP, ordQ, lcmCheck: this.lcm(ordP, ordQ) === ordN });
            }
            const orders = analysis.elements.map(e => e.ordN), uniqueOrders = [...new Set(orders)];
            let commonDivisor = uniqueOrders[0];
            for (const o of uniqueOrders) commonDivisor = this.gcd(commonDivisor, o);
            analysis.commonDivisor = commonDivisor;
            analysis.structureVisible = commonDivisor > 1 && ((p - 1) % commonDivisor === 0 || (q - 1) % commonDivisor === 0);
            return analysis;
        }
    }

    class FRONTIERExperiment {
        constructor(explorer) {
            this.explorer = explorer;
            this.semiprimeEC = new SemiprimeECAnalyzer(explorer);
            this.groupAnalyzer = new GroupStructureAnalyzer(explorer);
        }

        runFullExperiment(sampleSize = 100) {
            console.log('üî¨ FRONTIER Experiment: EC properties vs factor structure');
            const results = { timestamp: new Date().toISOString(), hypothesis: 'Do EC properties over ‚Ñ§/n‚Ñ§ reveal factor structure?', tests: {} };
            console.log('  Test 1: EC additivity across curves...');
            results.tests.ecAdditivity = {};
            for (const label of Object.keys(CURVE_DATABASE)) {
                results.tests.ecAdditivity[label] = this.semiprimeEC.batchTest(CURVE_DATABASE[label], 100, sampleSize);
            }
            console.log('  Test 2: Cross-curve revealing analysis...');
            const testSemiprimes = this.generateTestSemiprimes(20);
            const revealingCounts = {};
            for (const {n, p, q} of testSemiprimes) {
                for (const r of this.semiprimeEC.findRevealingCurves(n, p, q)) {
                    revealingCounts[r.curve] = (revealingCounts[r.curve] || 0) + 1;
                }
            }
            results.tests.revealingCurves = { testedSemiprimes: testSemiprimes.length, curveHits: revealingCounts,
                bestCurve: Object.entries(revealingCounts).sort((a, b) => b[1] - a[1])[0] || ['none', 0] };
            console.log('  Test 3: (‚Ñ§/n‚Ñ§)* structure visibility...');
            const groupResults = [];
            for (const {n, p, q} of testSemiprimes.slice(0, 10)) {
                const detection = this.groupAnalyzer.detectProductStructure(n);
                groupResults.push({ n, p, q, structureVisible: detection.structureVisible, commonDivisor: detection.commonDivisor });
            }
            results.tests.groupStructure = { tested: groupResults.length, visibleCount: groupResults.filter(r => r.structureVisible).length, results: groupResults };
            const ecSignal = Object.values(results.tests.ecAdditivity).some(a => a && Math.abs(parseFloat(a.correlationWithSum)) > 0.5);
            const groupSignal = results.tests.groupStructure.visibleCount > 0;
            results.verdict = { ecCorrelation: ecSignal ? 'SIGNAL DETECTED' : 'NO SIGNAL', groupStructure: groupSignal ? 'PARTIAL VISIBILITY' : 'HIDDEN',
                conclusion: (ecSignal || groupSignal) ? '‚ö†Ô∏è POTENTIAL SIGNAL ‚Äî warrants deeper investigation!' : '‚ùå NULL ‚Äî EC domain confirms OBSTRUCT finding' };
            console.log('‚úÖ FRONTIER Experiment complete:', results.verdict.conclusion);
            return results;
        }

        generateTestSemiprimes(count) {
            const primes = []; for (let i = 2; i <= 200; i++) if (PrimeMath.isPrime(i)) primes.push(i);
            const semiprimes = [], seen = new Set();
            while (semiprimes.length < count && semiprimes.length < primes.length * primes.length) {
                const p = primes[Math.floor(Math.random() * Math.min(primes.length, 20))];
                const q = primes[Math.floor(Math.random() * Math.min(primes.length, 20))];
                const n = p * q;
                if (!seen.has(n)) { seen.add(n); semiprimes.push({ n, p: Math.min(p, q), q: Math.max(p, q) }); }
            }
            return semiprimes;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: OrderGCDTelemetry ‚Äî Pollard p-1 style exploration
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class OrderGCDTelemetry {
        constructor() {
            this.history = [];
            this.currentRun = null;
            this.stepMode = false;
            this.currentK = 0;
            this.currentA = 2n;
            this.primes = this._sievePrimes(1000);
        }

        _sievePrimes(limit) {
            const sieve = new Array(limit + 1).fill(true);
            sieve[0] = sieve[1] = false;
            for (let i = 2; i * i <= limit; i++) {
                if (sieve[i]) for (let j = i * i; j <= limit; j += i) sieve[j] = false;
            }
            return sieve.map((v, i) => v ? i : 0).filter(x => x > 0);
        }

        gcd(a, b) {
            a = a < 0n ? -a : a;
            b = b < 0n ? -b : b;
            while (b > 0n) { const t = b; b = a % b; a = t; }
            return a;
        }

        modPow(base, exp, mod) {
            let result = 1n;
            base = base % mod;
            while (exp > 0n) {
                if (exp % 2n === 1n) result = (result * base) % mod;
                exp = exp / 2n;
                base = (base * base) % mod;
            }
            return result;
        }

        // Get exponent for step k based on heuristic
        getExponent(k, heuristic) {
            switch (heuristic) {
                case 'factorial': return BigInt(k);
                case 'primorial': return k <= this.primes.length ? BigInt(this.primes[k - 1]) : BigInt(k);
                case 'lcm': return BigInt(k);
                case 'powersmooth': {
                    // For power-smooth, use prime powers up to bound
                    const p = k <= this.primes.length ? this.primes[k - 1] : k;
                    let power = p;
                    while (power * p <= 500) power *= p;
                    return BigInt(power);
                }
                default: return BigInt(k);
            }
        }

        // Run full attack
        runAttack(n, bound, heuristic) {
            const nBig = BigInt(n);
            const startTime = performance.now();
            let a = 2n;
            let gcdChecks = 0;

            for (let k = 2; k <= bound; k++) {
                const exp = this.getExponent(k, heuristic);
                a = this.modPow(a, exp, nBig);
                gcdChecks++;

                const g = this.gcd(a - 1n, nBig);
                if (g > 1n && g < nBig) {
                    const elapsed = performance.now() - startTime;
                    const result = {
                        success: true,
                        n: n,
                        factor: Number(g),
                        otherFactor: n / Number(g),
                        foundAtK: k,
                        heuristic,
                        gcdChecks,
                        timeMs: elapsed.toFixed(2),
                        smoothness: this._estimateSmoothness(Number(g) - 1)
                    };
                    this.history.unshift(result);
                    if (this.history.length > 20) this.history.pop();
                    return result;
                }
            }

            const elapsed = performance.now() - startTime;
            const result = {
                success: false,
                n: n,
                bound,
                heuristic,
                gcdChecks,
                timeMs: elapsed.toFixed(2),
                reason: `No factor found with bound ${bound}`
            };
            this.history.unshift(result);
            if (this.history.length > 20) this.history.pop();
            return result;
        }

        // Initialize step mode
        initStepMode(n, heuristic) {
            this.currentRun = { n: BigInt(n), nNum: n, heuristic };
            this.currentK = 1;
            this.currentA = 2n;
            this.stepMode = true;
            return { k: 1, a: '2', gcd: '1', status: 'ready' };
        }

        // Execute one step
        step() {
            if (!this.stepMode || !this.currentRun) return null;

            this.currentK++;
            const exp = this.getExponent(this.currentK, this.currentRun.heuristic);
            this.currentA = this.modPow(this.currentA, exp, this.currentRun.n);

            const g = this.gcd(this.currentA - 1n, this.currentRun.n);

            if (g > 1n && g < this.currentRun.n) {
                this.stepMode = false;
                const result = {
                    success: true,
                    n: this.currentRun.nNum,
                    factor: Number(g),
                    otherFactor: this.currentRun.nNum / Number(g),
                    foundAtK: this.currentK,
                    heuristic: this.currentRun.heuristic
                };
                this.history.unshift(result);
                return { k: this.currentK, gcd: g.toString(), status: 'found', result };
            }

            return { k: this.currentK, gcd: g.toString(), status: 'continue' };
        }

        // Estimate smoothness of a number
        _estimateSmoothness(n) {
            if (n <= 1) return { bound: 0, factors: [] };
            let temp = n;
            let largestPrime = 1;
            const factors = [];

            for (const p of this.primes) {
                if (p * p > temp) break;
                while (temp % p === 0) {
                    factors.push(p);
                    if (p > largestPrime) largestPrime = p;
                    temp /= p;
                }
            }
            if (temp > 1) {
                factors.push(temp);
                largestPrime = temp;
            }

            return { bound: largestPrime, factors };
        }

        // Generate test cases
        generateSmoothSemiprime() {
            // Find primes p where p-1 is B-smooth for small B
            const smoothPrimes = [];
            for (let p = 3; p < 10000; p += 2) {
                if (!PrimeMath.isPrime(p)) continue;
                const smooth = this._estimateSmoothness(p - 1);
                if (smooth.bound <= 50) smoothPrimes.push({ p, smoothBound: smooth.bound });
            }

            if (smoothPrimes.length < 2) return { n: 1073, p: 29, q: 37, note: 'fallback' };

            const p1 = smoothPrimes[Math.floor(Math.random() * smoothPrimes.length)];
            const p2 = smoothPrimes[Math.floor(Math.random() * smoothPrimes.length)];

            return {
                n: p1.p * p2.p,
                p: Math.min(p1.p, p2.p),
                q: Math.max(p1.p, p2.p),
                pMinus1Smooth: p1.smoothBound,
                qMinus1Smooth: p2.smoothBound,
                note: `p-1 is ${p1.smoothBound}-smooth, q-1 is ${p2.smoothBound}-smooth`
            };
        }

        generateHardSemiprime() {
            // Find primes p where p-1 has a large prime factor
            const hardPrimes = [];
            for (let p = 1000; p < 50000; p++) {
                if (!PrimeMath.isPrime(p)) continue;
                const smooth = this._estimateSmoothness(p - 1);
                if (smooth.bound > 500) hardPrimes.push({ p, smoothBound: smooth.bound });
                if (hardPrimes.length > 100) break;
            }

            if (hardPrimes.length < 2) return { n: 8051, p: 83, q: 97, note: 'fallback' };

            const p1 = hardPrimes[Math.floor(Math.random() * hardPrimes.length)];
            const p2 = hardPrimes[Math.floor(Math.random() * hardPrimes.length)];

            return {
                n: p1.p * p2.p,
                p: Math.min(p1.p, p2.p),
                q: Math.max(p1.p, p2.p),
                pMinus1Smooth: p1.smoothBound,
                qMinus1Smooth: p2.smoothBound,
                note: `p-1 has prime factor ${p1.smoothBound}, q-1 has prime factor ${p2.smoothBound}`
            };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CLASS: PrimeExplorer ‚Äî Main application controller
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class PrimeExplorer {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.renderer = new Renderer(this.canvas);
            this.collapse = new CollapseAnimation();
            this.collapse.onComplete = () => this._showCollapseOverlay();

            // NEW: Tree animation and Multiplication lab
            this.treeAnim = new TreeAnimation();
            this.multLab = new MultiplicationLab(this);
            this.topoAnalyzer = new TopologyAnalyzer(this);

            // NEW: Advanced analysis tools
            this.resonanceAnalyzer = new ResonanceAnalyzer(this);
            this.neighborhoodAnalyzer = new NeighborhoodAnalyzer(this);
            this.constraintVisualizer = new ConstraintVisualizer(this);
            this.errorVectorAnalyzer = new ErrorVectorAnalyzer(this);

            // EC MODE
            this.ecMode = new ECModeAnalyzer(this);
            this.frontierExp = new FRONTIERExperiment(this);
            this.semiprimeEC = this.frontierExp.semiprimeEC;
            this.groupAnalyzer = this.frontierExp.groupAnalyzer;

            // BSD Visualizer
            this.bsdViz = new BSDVisualizer(this);

            // Order/GCD Telemetry
            this.orderGCD = new OrderGCDTelemetry();

            this.points = [];
            this.surface = SurfaceFactory.create('sphere');
            this.surfaceType = 'sphere'; // Track surface type for native mappings
            this.maxN = 5000;
            this.colorMode = 'type';
            this.mappingMethod = 'spiral';
            this.mappingMode = 'generic'; // NEW: generic, native, primeIndex, gapBased, residueFingerprint
            this.basePointSize = 3;

            // Display filters - what to SHOW
            this.showPrimes = true; 
            this.showSemiprimes = false; 
            this.showComposites = false;
            this.showWireframe = false; 
            this.autoRotate = true; 
            this.helixFilter = null;

            // Prime type visibility filters
            this.primeTypeFilters = { 
                regular: true, 
                twin: true, 
                sophie: true, 
                mersenne: true, 
                supersingular: true, 
                safe: true 
            };

            this.isDragging = false; 
            this.lastMouse = {x:0, y:0}; 
            this.hoveredPoint = null; 
            this.selectedPoint = null;

            this._setupEvents();
        }

        init() { 
            this.renderer.resize(); 
            this.generatePoints(); 
            this._animate(); 
        }

        // FIX: Generate ALL points, filtering happens in render()
        generatePoints() {
            this.points = [];
            let primeCount = 0, specialCount = 0;

            for (let n = 2; n <= this.maxN; n++) {
                const point = new Point(n);

                // Count stats
                if (point.isPrime) {
                    primeCount++;
                    if (point.primeType !== 'regular') specialCount++;
                }

                // Calculate position for ALL points - now with mode and surface type
                const {t, theta, phi} = MappingStrategy.map(n, this.maxN, this.mappingMethod, point.isPrime, this.mappingMode, this.surfaceType);
                const pos = this.surface.mapPoint(t, theta, phi, point.isPrime);
                point.setPosition(pos.x, pos.y, pos.z);
                point.setColor(ColorScheme.getColor(point, this.colorMode));

                // EC Mode color override for primes
                if (this.ecMode && this.ecMode.enabled && point.isPrime) {
                    const ecColor = this.ecMode.getColor(point.n);
                    if (ecColor) point.setColor(ecColor);
                }

                // Add ALL points - visibility filtering happens in render()
                this.points.push(point);
            }

            document.getElementById('statTotal').textContent = this.points.length;
            document.getElementById('statPrimes').textContent = primeCount;
            document.getElementById('statSpecial').textContent = specialCount;
        }

        render() {
            this.renderer.clear();

            if (this.showWireframe) {
                this.renderer.drawWireframe(this.surface.getWireframe());
            }

            // Filter points for visibility
            let visible = this.points.filter(p => {
                // Prime visibility
                if (p.isPrime) {
                    if (!this.showPrimes) return false;
                    // Check prime type filters
                    if (!this.primeTypeFilters[p.primeType]) return false;
                }
                // Semiprime visibility
                else if (p.isSemiprime) {
                    if (!this.showSemiprimes) return false;
                }
                // Composite visibility (non-prime, non-semiprime)
                else {
                    if (!this.showComposites) return false;
                }

                // EC Mode filter
                if (this.ecMode && this.ecMode.enabled) {
                    if (!this.ecMode.shouldShow(p.n)) return false;
                }

                // Helix divisibility filter
                if (this.helixFilter && p.n % this.helixFilter !== 0) return false;

                return true;
            });

            // Sort by z-depth for proper rendering
            visible.sort((a, b) => this.renderer.project(a).z - this.renderer.project(b).z);

            // Draw collapse animation connections
            if (this.collapse.phase >= 2) {
                for (let i = 0; i < this.collapse.factorPoints.length; i++) {
                    const prog = Math.min(1, this.collapse.progress * 2 - i * 0.15);
                    if (prog > 0) {
                        this.renderer.drawConnection(
                            this.collapse.target, 
                            this.collapse.factorPoints[i], 
                            prog, 
                            this.collapse.target.hex, 
                            this.collapse.factorPoints[i].hex
                        );
                    }
                }
            }

            // NEW: Draw tree animation path
            if (this.treeAnim.active && this.treeAnim.pathPoints.length > 0) {
                this.renderer.drawTreePath(this.treeAnim.pathPoints, this.treeAnim.progress);
            }

            // NEW: Draw multiplication error vector
            if (this.multLab.showVector && this.multLab.currentResult) {
                const r = this.multLab.currentResult;
                const predPoint = { x: r.predicted.x, y: r.predicted.y, z: r.predicted.z };
                this.renderer.drawErrorVector(predPoint, r.pointPQ, '#ff6b6b');
            }

            // Draw all visible points
            for (const p of visible) {
                const isSelected = this.selectedPoint?.n === p.n;
                const isFactor = this.collapse.factorPoints.some(f => f.n === p.n);
                const isTreeNode = this.treeAnim.pathPoints.some(tp => tp.n === p.n);
                const isMultPoint = this.multLab.currentResult && 
                    (p.n === this.multLab.currentResult.p || 
                     p.n === this.multLab.currentResult.q || 
                     p.n === this.multLab.currentResult.p * this.multLab.currentResult.q);

                let size = this.basePointSize * (p.isPrime ? 1.3 : p.isSemiprime ? 1.1 : 0.8);
                if (isSelected) size = this.basePointSize * 4 + (this.collapse.phase === 1 ? Math.sin(Date.now()/150)*2 : 0);
                if (isFactor) size = this.basePointSize * 3.5;
                if (isTreeNode) size = this.basePointSize * 3;
                if (isMultPoint) size = this.basePointSize * 3;

                // Apply hub coloring if enabled
                let pointToDraw = p;
                if (this.topoAnalyzer.colorByHub && this.topoAnalyzer.hubScores.size > 0) {
                    const hubColor = this.topoAnalyzer.getHubColor(p.n);
                    if (hubColor) {
                        // Create temporary point with hub color
                        pointToDraw = { ...p, color: hubColor, hex: `rgb(${hubColor.r},${hubColor.g},${hubColor.b})` };
                    }
                }

                this.renderer.drawPoint(pointToDraw, size, isSelected || isFactor || isTreeNode || isMultPoint);
            }

            // Draw labels
            if (this.collapse.phase >= 1 && this.selectedPoint) {
                this.renderer.drawLabel(this.selectedPoint, this.selectedPoint.n.toString());
            }
            if (this.collapse.phase >= 3) {
                for (const fp of this.collapse.factorPoints) {
                    this.renderer.drawLabel(fp, fp.n.toString(), '#ffd93d');
                }
            }

            // NEW: Draw tree node labels
            if (this.treeAnim.pathPoints.length > 0) {
                for (const tp of this.treeAnim.pathPoints) {
                    this.renderer.drawLabel(tp, tp.n.toString(), '#9d4edd');
                }
            }

            // NEW: Draw mult lab labels
            if (this.multLab.currentResult) {
                const r = this.multLab.currentResult;
                this.renderer.drawLabel(r.pointP, `p=${r.p}`, '#4ecdc4');
                this.renderer.drawLabel(r.pointQ, `q=${r.q}`, '#4ecdc4');
                this.renderer.drawLabel(r.pointPQ, `${r.p}√ó${r.q}`, '#ffd93d');
            }
        }

        _animate() {
            if (this.autoRotate && this.collapse.phase !== 2 && !this.treeAnim.active) {
                this.renderer.rotation.y += 0.003;
            }
            this.collapse.update();
            this.treeAnim.update();
            this.render();
            requestAnimationFrame(() => this._animate());
        }

        setSurface(type) { 
            this.surfaceType = type; // Track for native mappings
            this.surface = SurfaceFactory.create(type); 
            this.multLab.errorCache = []; // Clear cache on geometry change
            this.multLab.currentResult = null;
            this.selectedPoint = null; // Clear selection on surface change
            this.collapse.phase = 0; // Reset collapse animation
            document.getElementById('minErrorResult').classList.remove('visible');
            document.getElementById('minErrorResult').innerHTML = '';
            this.generatePoints(); 
            this._updateSurfaceInfo(); 
        }

        setMapping(method) { 
            this.mappingMethod = method; 
            this.multLab.errorCache = []; // Clear cache on geometry change
            this.multLab.currentResult = null;
            this.selectedPoint = null; // Clear selection on mapping change
            this.collapse.phase = 0; // Reset collapse animation
            document.getElementById('minErrorResult').classList.remove('visible');
            document.getElementById('minErrorResult').innerHTML = '';
            this.generatePoints(); 
        }

        // NEW: Set mapping mode (generic, native, primeIndex, etc.)
        setMappingMode(mode) {
            this.mappingMode = mode;
            this.multLab.errorCache = []; // Clear cache
            this.multLab.currentResult = null;
            this.selectedPoint = null;
            this.collapse.phase = 0;
            // Clear prime index cache when switching modes (it can get large)
            if (mode !== 'primeIndex') {
                MappingStrategy.primeIndexCache.clear();
            }
            document.getElementById('minErrorResult').classList.remove('visible');
            document.getElementById('minErrorResult').innerHTML = '';
            this.generatePoints();
            showToast(`Mapping mode: ${mode}`, 'info');
        }

        setColorMode(mode) { 
            this.colorMode = mode; 
            this.generatePoints(); 
        }

        setMaxN(n) { 
            this.maxN = n; 
            this.multLab.errorCache = []; // Clear cache on range change
            this.multLab.currentResult = null;
            document.getElementById('minErrorResult').classList.remove('visible');
            document.getElementById('minErrorResult').innerHTML = '';
            this.generatePoints(); 
        }

        _updateSurfaceInfo() {
            document.getElementById('surfaceInfo').innerHTML = 
                '<h4>' + this.surface.name + '</h4><p>' + this.surface.description + '</p>';
        }

        findNumber(n) {
            if (n < 2) return;

            const point = new Point(n);
            const {t, theta, phi} = MappingStrategy.map(n, Math.max(n, this.maxN), this.mappingMethod, point.isPrime, this.mappingMode, this.surfaceType);
            const pos = this.surface.mapPoint(t, theta, phi, point.isPrime);
            point.setPosition(pos.x, pos.y, pos.z);
            point.setColor(ColorScheme.getColor(point, this.colorMode));

            this.selectedPoint = point;
            this.collapse.select(point);

            document.getElementById('factorResult').classList.add('visible');
            document.getElementById('resultN').textContent = n;
            document.getElementById('resultType').textContent = point.isPrime 
                ? 'Prime (' + point.primeType + ')' 
                : (point.isSemiprime ? 'Semiprime' : 'Composite');

            document.getElementById('resultFactors').innerHTML = point.factors.map(f => {
                const fp = new Point(f); 
                fp.setColor(ColorScheme.getColor(fp, this.colorMode));
                const tc = (fp.color.r + fp.color.g + fp.color.b) > 380 ? '#000' : '#fff';
                return '<span class="factor-chip" style="background:' + fp.hex + ';color:' + tc + '">' + f + '</span>';
            }).join(' √ó ');

            document.getElementById('collapseBtn').disabled = point.isPrime;

            if (n > this.maxN) { 
                this.maxN = Math.ceil(n/500)*500; 
                document.getElementById('maxN').value = this.maxN; 
                document.getElementById('rangeValue').textContent = this.maxN; 
                this.generatePoints(); 
            }
        }

        triggerCollapse() {
            if (!this.selectedPoint || this.selectedPoint.isPrime) return;

            const uniqueFactors = [...new Set(this.selectedPoint.factors)];
            const factorPoints = uniqueFactors.map(f => {
                let fp = this.points.find(p => p.n === f);
                if (!fp) {
                    fp = new Point(f);
                    const {t, theta, phi} = MappingStrategy.map(f, this.maxN, this.mappingMethod, fp.isPrime, this.mappingMode, this.surfaceType);
                    const pos = this.surface.mapPoint(t, theta, phi, fp.isPrime);
                    fp.setPosition(pos.x, pos.y, pos.z);
                    fp.setColor(ColorScheme.getColor(fp, this.colorMode));
                }
                return fp;
            });

            this.collapse.start(this.selectedPoint, factorPoints);
        }

        _showCollapseOverlay() {
            const overlay = document.getElementById('collapseOverlay');
            overlay.classList.add('visible');

            document.getElementById('overlayFactors').innerHTML = this.selectedPoint.factors.map(f => {
                const fp = new Point(f); 
                fp.setColor(ColorScheme.getColor(fp, this.colorMode));
                const tc = (fp.color.r + fp.color.g + fp.color.b) > 400 ? '#000' : '#fff';
                return '<span style="background:' + fp.hex + ';color:' + tc + '">' + f + '</span>';
            }).join(' √ó ');

            setTimeout(() => overlay.classList.remove('visible'), 2500);
        }

        // NEW: Build and display factor tree
        buildTree(n) {
            if (n < 4 || PrimeMath.isPrime(n)) {
                alert('Enter a composite number ‚â• 4');
                return;
            }

            const steps = PrimeMath.getDescentSteps(n);
            const pathPoints = [];

            // Create points for each unique number in the descent
            const seen = new Set();
            for (const step of steps) {
                if (!seen.has(step.n)) {
                    const point = this.multLab.getPosition(step.n);
                    pathPoints.push(point);
                    seen.add(step.n);
                }
                if (step.factors) {
                    for (const f of step.factors) {
                        if (!seen.has(f)) {
                            pathPoints.push(this.multLab.getPosition(f));
                            seen.add(f);
                        }
                    }
                }
            }

            this.treeAnim.pathPoints = pathPoints;
            this.treeAnim.steps = steps;

            // Display path in UI
            const pathEl = document.getElementById('treePath');
            pathEl.classList.add('visible');

            const factors = PrimeMath.factorize(n);
            let html = '<div style="color:#9d4edd;font-weight:bold;margin-bottom:6px;">Descent Path:</div>';
            html += `<div class="tree-step" style="border-color:#ffd93d;">${n} (start)</div>`;

            for (const step of steps) {
                if (step.factors) {
                    html += `<div class="tree-step">${step.n} = ${step.smallest} √ó ${step.remainder}</div>`;
                }
            }

            html += `<div class="tree-step" style="border-color:#00ff88;">‚Üí ${factors.join(' √ó ')} (primes)</div>`;
            pathEl.innerHTML = html;

            document.getElementById('animateTreeBtn').disabled = false;
        }

        // NEW: Animate tree descent
        animateTree() {
            if (this.treeAnim.pathPoints.length === 0) return;
            this.treeAnim.start(this.treeAnim.pathPoints, this.treeAnim.steps);
        }

        // NEW: Reset view to default
        resetView() {
            this.renderer.rotation = { x: 0.3, y: 0 };
            this.renderer.zoom = 1.0;
            this.renderer.panOffset = { x: 0, y: 0 };
            document.getElementById('zoomLevel').textContent = '1.0x';
        }

        // NEW: Center view (reset pan only)
        centerView() {
            this.renderer.panOffset = { x: 0, y: 0 };
        }

        // NEW: Zoom controls
        zoomIn() {
            this.renderer.zoom = Math.min(4.0, this.renderer.zoom + 0.2);
            document.getElementById('zoomLevel').textContent = this.renderer.zoom.toFixed(1) + 'x';
        }

        zoomOut() {
            this.renderer.zoom = Math.max(0.3, this.renderer.zoom - 0.2);
            document.getElementById('zoomLevel').textContent = this.renderer.zoom.toFixed(1) + 'x';
        }

        // NEW: Pan controls
        panUp() {
            this.renderer.panOffset.y -= 50;
        }

        panDown() {
            this.renderer.panOffset.y += 50;
        }

        panLeft() {
            this.renderer.panOffset.x -= 50;
        }

        panRight() {
            this.renderer.panOffset.x += 50;
        }

        // NEW: Camera preset views
        // Coordinate system: X=right, Y=up, Z=toward viewer (after projection)
        // Sphere: phi=0 ‚Üí z=1 (north pole at +Z), phi=œÄ ‚Üí z=-1 (south pole at -Z)

        viewFromTop() {
            // See North Pole at center of screen
            // With rotX=0, rotY=0: pole (0,0,1) projects to screen center
            // Smooth numbers (near pole) appear as bright cluster at center
            this.renderer.rotation.x = 0;
            this.renderer.rotation.y = 0;
            this.renderer.panOffset = { x: 0, y: 0 };
        }

        viewFromBottom() {
            // See South Pole at center (flip upside down)
            this.renderer.rotation.x = Math.PI;
            this.renderer.rotation.y = 0;
            this.renderer.panOffset = { x: 0, y: 0 };
        }

        viewFromSide() {
            // Tilted side view (equator visible as horizontal band)
            this.renderer.rotation.x = 0.3;
            this.renderer.rotation.y = 0;
            this.renderer.panOffset = { x: 0, y: 0 };
        }

        _setupEvents() {
            // Debounced resize handler - fixes browser zoom issues
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    this.renderer.resize();
                }, 100);
            });

            // Track which button is pressed
            this.dragButton = 0;

            this.canvas.addEventListener('mousedown', e => { 
                this.isDragging = true; 
                this.dragButton = e.button; // 0=left, 1=middle, 2=right
                this.lastMouse = {x: e.clientX, y: e.clientY}; 

                // Prevent context menu on right-click
                if (e.button === 2) e.preventDefault();
            });

            this.canvas.addEventListener('contextmenu', e => e.preventDefault());

            this.canvas.addEventListener('mousemove', e => {
                if (this.isDragging) {
                    const dx = e.clientX - this.lastMouse.x;
                    const dy = e.clientY - this.lastMouse.y;

                    if (this.dragButton === 0) {
                        // Left-click: rotate
                        this.renderer.rotation.y += dx * 0.01;
                        this.renderer.rotation.x += dy * 0.01;
                    } else if (this.dragButton === 1 || this.dragButton === 2) {
                        // Middle or right-click: pan
                        this.renderer.panOffset.x += dx;
                        this.renderer.panOffset.y += dy;
                    }

                    this.lastMouse = {x: e.clientX, y: e.clientY};
                }

                const rect = this.canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (this.canvas.width / rect.width);
                const my = (e.clientY - rect.top) * (this.canvas.height / rect.height);
                this.hoveredPoint = this.renderer.findPointAt(mx, my, this.points);
                this._updateHoverInfo();
            });

            this.canvas.addEventListener('mouseup', () => { 
                this.isDragging = false; 
                this.dragButton = 0;
            });

            this.canvas.addEventListener('mouseleave', () => { 
                this.isDragging = false; 
                this.dragButton = 0;
                this.hoveredPoint = null; 
                document.getElementById('hoverInfo').classList.remove('visible'); 
            });

            this.canvas.addEventListener('click', e => { 
                // Only select on left-click, not after panning
                if (e.button === 0 && this.hoveredPoint) { 
                    document.getElementById('searchN').value = this.hoveredPoint.n; 
                    this.findNumber(this.hoveredPoint.n); 
                } 
            });

            // Wheel zoom - works with mouse wheel and touchpad pinch
            this.canvas.addEventListener('wheel', e => { 
                e.preventDefault(); 

                // Detect if it's a pinch gesture (ctrlKey is set for pinch on touchpad)
                const delta = e.ctrlKey ? e.deltaY * 0.01 : e.deltaY * 0.001;
                this.renderer.zoom = Math.max(0.3, Math.min(4.0, this.renderer.zoom - delta)); 
                document.getElementById('zoomLevel').textContent = this.renderer.zoom.toFixed(1) + 'x'; 
            }, {passive: false});

            // TOUCH SUPPORT FOR MOBILE
            this.touchStartDist = 0;
            this.touchStartZoom = 1;

            this.canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    // Single touch: rotate
                    this.isDragging = true;
                    this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Two fingers: pinch to zoom
                    this.isDragging = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    this.touchStartDist = Math.sqrt(dx * dx + dy * dy);
                    this.touchStartZoom = this.renderer.zoom;
                }
            }, { passive: false });

            this.canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDragging) {
                    // Single touch drag: rotate
                    const dx = e.touches[0].clientX - this.lastMouse.x;
                    const dy = e.touches[0].clientY - this.lastMouse.y;
                    this.renderer.rotation.y += dx * 0.01;
                    this.renderer.rotation.x += dy * 0.01;
                    this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const scale = dist / this.touchStartDist;
                    this.renderer.zoom = Math.max(0.3, Math.min(4.0, this.touchStartZoom * scale));
                    document.getElementById('zoomLevel').textContent = this.renderer.zoom.toFixed(1) + 'x';
                }
            }, { passive: false });

            this.canvas.addEventListener('touchend', e => {
                this.isDragging = false;
            });
        }

        _updateHoverInfo() {
            const el = document.getElementById('hoverInfo');
            if (this.hoveredPoint) {
                el.classList.add('visible');
                document.getElementById('hoverN').textContent = this.hoveredPoint.n;
                document.getElementById('hoverType').textContent = this.hoveredPoint.isPrime 
                    ? 'Prime (' + this.hoveredPoint.primeType + ')' 
                    : (this.hoveredPoint.isSemiprime ? 'Semiprime' : 'Composite');
                document.getElementById('hoverFactors').textContent = this.hoveredPoint.factors.join(' √ó ');
                document.getElementById('hoverSpecial').textContent = 
                    this.hoveredPoint.primeType && this.hoveredPoint.primeType !== 'regular' 
                        ? '‚ú® ' + this.hoveredPoint.primeType : '';
                document.getElementById('hoverColor').style.background = this.hoveredPoint.hex;
            } else {
                el.classList.remove('visible');
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI BINDINGS & INITIALIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function toggleSection(header) { 
        header.parentElement.classList.toggle('collapsed'); 
    }

    const explorer = new PrimeExplorer('canvas');

    // Surface and mapping
    document.getElementById('surfaceType').addEventListener('change', e => explorer.setSurface(e.target.value));
    document.getElementById('mappingMethod').addEventListener('change', e => explorer.setMapping(e.target.value));
    document.getElementById('mappingMode').addEventListener('change', e => {
        const mode = e.target.value;
        explorer.setMappingMode(mode);

        // Gray out Mapping Method dropdown when native mode (it's bypassed)
        const methodDropdown = document.getElementById('mappingMethod');
        if (mode === 'native') {
            methodDropdown.disabled = true;
            methodDropdown.style.opacity = '0.5';
            methodDropdown.title = 'Native mode uses geometry-specific mapping (bypasses this dropdown)';
        } else {
            methodDropdown.disabled = false;
            methodDropdown.style.opacity = '1';
            methodDropdown.title = mode === 'generic' 
                ? 'Select parameterization formula' 
                : `Applied to transformed n (${mode} mode)`;
        }
    });

    // Range controls
    document.getElementById('maxN').addEventListener('input', e => { 
        document.getElementById('rangeValue').textContent = e.target.value; 
        explorer.setMaxN(parseInt(e.target.value)); 
    });
    document.getElementById('pointSize').addEventListener('input', e => { 
        document.getElementById('sizeValue').textContent = e.target.value; 
        explorer.basePointSize = parseFloat(e.target.value); 
    });

    // Color mode
    document.getElementById('colorMode').addEventListener('change', e => explorer.setColorMode(e.target.value));

    // Prime type filters
    ['showRegular','showTwin','showSophie','showMersenne','showSupersingular','showSafe'].forEach(id => {
        document.getElementById(id).addEventListener('change', e => { 
            explorer.primeTypeFilters[id.replace('show','').toLowerCase()] = e.target.checked; 
        });
    });

    // Display toggles
    document.getElementById('btnPrimes').addEventListener('click', e => { 
        explorer.showPrimes = !explorer.showPrimes; 
        e.target.classList.toggle('active', explorer.showPrimes); 
    });
    document.getElementById('btnSemiprimes').addEventListener('click', e => { 
        explorer.showSemiprimes = !explorer.showSemiprimes; 
        e.target.classList.toggle('active', explorer.showSemiprimes); 
    });
    document.getElementById('btnComposites').addEventListener('click', e => { 
        // "All" button: show ALL number types
        const allOn = explorer.showPrimes && explorer.showSemiprimes && explorer.showComposites;
        if (allOn) {
            // Turn off composites only (keep primes)
            explorer.showComposites = false;
            explorer.showSemiprimes = false;
            e.target.classList.remove('active');
        } else {
            // Turn ALL on
            explorer.showPrimes = true;
            explorer.showSemiprimes = true;
            explorer.showComposites = true;
            e.target.classList.add('active');
            document.getElementById('btnPrimes').classList.add('active');
            document.getElementById('btnSemiprimes').classList.add('active');
        }
    });
    document.getElementById('btnWireframe').addEventListener('click', e => { 
        explorer.showWireframe = !explorer.showWireframe; 
        e.target.classList.toggle('active', explorer.showWireframe); 
    });
    document.getElementById('btnRotate').addEventListener('click', e => { 
        explorer.autoRotate = !explorer.autoRotate; 
        e.target.classList.toggle('active', explorer.autoRotate); 
    });

    // Helix filter buttons
    document.querySelectorAll('.prime-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const p = parseInt(btn.dataset.prime);
            if (explorer.helixFilter === p) { 
                explorer.helixFilter = null; 
                btn.classList.remove('active'); 
            } else { 
                document.querySelectorAll('.prime-btn').forEach(b => b.classList.remove('active')); 
                explorer.helixFilter = p; 
                btn.classList.add('active'); 
            }
            document.getElementById('filterStatus').textContent = 
                explorer.helixFilter ? 'Multiples of ' + explorer.helixFilter : 'No filter';
        });
    });

    document.getElementById('clearFilter').addEventListener('click', () => { 
        explorer.helixFilter = null; 
        document.querySelectorAll('.prime-btn').forEach(b => b.classList.remove('active')); 
        document.getElementById('filterStatus').textContent = 'No filter'; 
    });

    // Search and collapse
    document.getElementById('searchBtn').addEventListener('click', () => { 
        const n = parseInt(document.getElementById('searchN').value); 
        if (n >= 2) explorer.findNumber(n); 
    });
    document.getElementById('searchN').addEventListener('keypress', e => { 
        if (e.key === 'Enter') { 
            const n = parseInt(e.target.value); 
            if (n >= 2) explorer.findNumber(n); 
        } 
    });
    document.getElementById('collapseBtn').addEventListener('click', () => explorer.triggerCollapse());

    // NEW: Multiplication Lab bindings

    // Feature mode selector
    document.getElementById('featureMode').addEventListener('change', e => {
        explorer.multLab.featureMode = e.target.value;
        explorer.multLab.errorCache = []; // Clear cache on mode change

        // Update labels
        const mode = e.target.value;
        const labels = {
            position: { p: 'Pos(p):', q: 'Pos(q):', sum: 'Pos(p)+Pos(q):', pq: 'Pos(p√óq):' },
            log: { p: 'Log(p):', q: 'Log(q):', sum: 'Log(p)+Log(q):', pq: 'Log(p√óq):' },
            valuation: { p: 'V(p):', q: 'V(q):', sum: 'V(p)+V(q):', pq: 'V(p√óq):' },
            mixed: { p: 'Œ¶(p):', q: 'Œ¶(q):', sum: 'Œ¶(p)+Œ¶(q):', pq: 'Œ¶(p√óq):' },
            residue: { p: 'R(p):', q: 'R(q):', sum: 'R(p)+R(q):', pq: 'R(p√óq):' },
            residueZero: { p: 'Z(p):', q: 'Z(q):', sum: 'Z(p)+Z(q):', pq: 'Z(p√óq):' }
        };
        const l = labels[mode] || labels.position;
        document.getElementById('labelP').textContent = l.p;
        document.getElementById('labelQ').textContent = l.q;
        document.getElementById('labelSum').textContent = l.sum;
        document.getElementById('labelPQ').textContent = l.pq;

        // Update explanation
        const explanations = {
            position: '<strong>Position:</strong> Tests if geometric position is additive under multiplication. (Usually fails)',
            log: '<strong>Log:</strong> log(p√óq) = log(p) + log(q) <em>exactly!</em> Error should be ~0 for all pairs.',
            valuation: '<strong>Valuation:</strong> v_p(a√ób) = v_p(a) + v_p(b) <em>exactly!</em> Uses powers of 2,3,5.',
            mixed: '<strong>Mixed:</strong> Combines log, valuations, and residues. Experimental blend.',
            residue: '<strong>Residue:</strong> Uses (n mod 7, n mod 11, n mod 13). Shows divisibility patterns.',
            residueZero: '<strong>Residue Zero-Dist:</strong> Distance to nearest divisibility. 0 = divisible! <em>Factor detection mode.</em>'
        };
        document.getElementById('featureExplain').innerHTML = explanations[mode] || explanations.position;

        // Clear results display
        document.getElementById('minErrorResult').classList.remove('visible');
    });

    document.getElementById('multBtn').addEventListener('click', () => {
        const p = parseInt(document.getElementById('multP').value);
        const q = parseInt(document.getElementById('multQ').value);
        if (!p || !q || p < 2 || q < 2) {
            alert('Enter two numbers ‚â• 2');
            return;
        }

        const result = explorer.multLab.compute(p, q);
        const rankInfo = explorer.multLab.getRank(result.error);

        document.getElementById('multResult').classList.add('visible');

        // Display feature values (not just position)
        document.getElementById('posP').textContent = `(${result.featP.x.toFixed(3)}, ${result.featP.y.toFixed(3)}, ${result.featP.z.toFixed(3)})`;
        document.getElementById('posQ').textContent = `(${result.featQ.x.toFixed(3)}, ${result.featQ.y.toFixed(3)}, ${result.featQ.z.toFixed(3)})`;
        document.getElementById('posSum').textContent = `(${result.predicted.x.toFixed(3)}, ${result.predicted.y.toFixed(3)}, ${result.predicted.z.toFixed(3)})`;
        document.getElementById('posPQ').textContent = `(${result.actual.x.toFixed(3)}, ${result.actual.y.toFixed(3)}, ${result.actual.z.toFixed(3)})`;

        const errorEl = document.getElementById('errorDelta');
        errorEl.textContent = result.error.toFixed(6);

        // Color based on error magnitude
        if (result.error < 0.0001) {
            errorEl.className = 'good';
            errorEl.style.color = '#00ff88';
        } else if (result.error < 0.1) {
            errorEl.className = 'good';
            errorEl.style.color = '#4ecdc4';
        } else {
            errorEl.className = 'error';
            errorEl.style.color = '#ff6b6b';
        }

        const percentile = (rankInfo.rank / rankInfo.total) * 100;
        let rankClass = 'rank-poor';
        if (percentile <= 10) rankClass = 'rank-top';
        else if (percentile <= 25) rankClass = 'rank-good';
        else if (percentile <= 50) rankClass = 'rank-avg';

        document.getElementById('errorRank').innerHTML = `<span class="rank-indicator ${rankClass}">#${rankInfo.rank}/${rankInfo.total}</span>`;
    });

    document.getElementById('showVectorBtn').addEventListener('click', () => {
        explorer.multLab.showVector = !explorer.multLab.showVector;
        document.getElementById('showVectorBtn').classList.toggle('active', explorer.multLab.showVector);
    });

    document.getElementById('findMinErrorBtn').addEventListener('click', () => {
        const btn = document.getElementById('findMinErrorBtn');
        btn.textContent = 'Searching...';
        btn.disabled = true;

        setTimeout(() => {
            // Clear cache first to force fresh calculation
            explorer.multLab.errorCache = [];
            const results = explorer.multLab.findMinimalErrorPairs(50, 50);

            const timestamp = new Date().toLocaleTimeString();
            let html = `<div style="color:#00ff88;font-weight:bold;margin-bottom:4px;">Top 5 Minimal Error Pairs <span style="color:#666;font-size:0.5rem;">(${timestamp})</span>:</div>`;
            results.slice(0, 5).forEach((r, i) => {
                html += `<div style="font-size:0.65rem;cursor:pointer;" onclick="document.getElementById('multP').value=${r.p};document.getElementById('multQ').value=${r.q};">${i+1}. ${r.p} √ó ${r.q} = ${r.p*r.q} ‚Üí Œî ${r.error.toFixed(4)}</div>`;
            });

            const el = document.getElementById('minErrorResult');
            el.innerHTML = html;
            el.classList.add('visible');

            btn.textContent = 'Find Min Error';
            btn.disabled = false;
        }, 50);
    });

    // NEW: Factor Tree bindings
    document.getElementById('treeBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('treeN').value);
        if (n >= 4) explorer.buildTree(n);
    });
    document.getElementById('treeN').addEventListener('keypress', e => {
        if (e.key === 'Enter') {
            const n = parseInt(e.target.value);
            if (n >= 4) explorer.buildTree(n);
        }
    });
    document.getElementById('animateTreeBtn').addEventListener('click', () => explorer.animateTree());

    // Legacy additive test (kept for compatibility)
    document.getElementById('testBtn')?.addEventListener('click', () => {
        const p = parseInt(document.getElementById('testP').value);
        const q = parseInt(document.getElementById('testQ').value);
        if (!p || !q) return;

        const result = explorer.multLab.compute(p, q);
        document.getElementById('testResult').classList.add('visible');
        document.getElementById('testResult').textContent = 
            `Pos(${p})+Pos(${q}) vs Pos(${p*q}): Œî = ${result.error.toFixed(4)}`;
    });

    // NEW: Topology Analysis bindings
    document.getElementById('hubRadius').addEventListener('input', e => {
        document.getElementById('radiusValue').textContent = e.target.value;
        explorer.topoAnalyzer.radius = parseFloat(e.target.value);
    });

    document.getElementById('analyzeTopologyBtn').addEventListener('click', () => {
        const btn = document.getElementById('analyzeTopologyBtn');
        btn.textContent = 'Analyzing...';
        btn.disabled = true;

        // Use setTimeout to allow UI update
        setTimeout(() => {
            const stats = explorer.topoAnalyzer.analyze();

            // Display results
            document.getElementById('topologyResult').classList.add('visible');

            // Hub stats
            document.getElementById('hubStats').innerHTML = `
                <div>Max hub score: <strong>${stats.maxScore}</strong></div>
                <div>Analysis radius: <strong>${explorer.topoAnalyzer.radius.toFixed(2)}</strong></div>
            `;

            // Prime vs Composite comparison
            const ratio = stats.ratio.toFixed(2);
            const ratioClass = stats.ratio > 1.1 ? 'hub-high' : stats.ratio > 0.9 ? 'hub-med' : 'hub-low';
            document.getElementById('primeVsComposite').innerHTML = `
                <div class="topo-compare">
                    <div class="topo-prime">
                        <div class="topo-value" style="color:#ff6b6b;">${stats.primeAvg.toFixed(1)}</div>
                        <div class="topo-label">Prime Avg Hub</div>
                    </div>
                    <div class="topo-composite">
                        <div class="topo-value" style="color:#888;">${stats.compositeAvg.toFixed(1)}</div>
                        <div class="topo-label">Composite Avg Hub</div>
                    </div>
                </div>
                <div style="text-align:center;margin-top:8px;">
                    Composite/Prime ratio: <span class="${ratioClass}" style="font-weight:bold;font-size:1.1rem;">${ratio}x</span>
                </div>
                <div style="text-align:center;margin-top:6px;font-size:0.6rem;color:#888;">
                    In top ${stats.top10PercentSize} positions (10%): 
                    <span style="color:#ff6b6b;">${stats.primesInTop} primes</span> vs 
                    <span style="color:#aaa;">${stats.compositesInTop} composites</span>
                </div>
            `;

            // Top hubs
            document.getElementById('topHubs').innerHTML = stats.topHubs.map((h, i) => {
                const typeLabel = h.isPrime ? '<span style="color:#ff6b6b;">P</span>' : '<span style="color:#888;">C</span>';
                return `<div>${i+1}. <strong>${h.n}</strong> ${typeLabel} ‚Äî score: ${h.score}</div>`;
            }).join('');

            btn.textContent = 'Analyze';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('colorByHubBtn').addEventListener('click', e => {
        explorer.topoAnalyzer.colorByHub = !explorer.topoAnalyzer.colorByHub;
        e.target.classList.toggle('active', explorer.topoAnalyzer.colorByHub);

        if (explorer.topoAnalyzer.colorByHub && explorer.topoAnalyzer.hubScores.size === 0) {
            // Auto-analyze if not done yet
            document.getElementById('analyzeTopologyBtn').click();
        }
    });

    // NEW: Batch analysis across all configurations
    document.getElementById('batchAnalysisBtn').addEventListener('click', () => {
        const btn = document.getElementById('batchAnalysisBtn');
        btn.textContent = 'Testing...';
        btn.disabled = true;

        setTimeout(() => {
            const results = explorer.topoAnalyzer.batchAnalysis(explorer);

            // Sort by composites in top 10 (descending)
            results.sort((a, b) => b.compositesInTop10 - a.compositesInTop10);

            // Calculate summary
            const avgRatio = results.reduce((s, r) => s + r.ratio, 0) / results.length;
            const avgCompInTop10 = results.reduce((s, r) => s + r.compositesInTop10, 0) / results.length;

            let html = `<div style="color:#00ff88;font-weight:bold;margin-bottom:8px;">
                üß™ BATCH ANALYSIS: ${results.length} configurations tested
            </div>`;

            html += `<div style="margin-bottom:8px;padding:6px;background:rgba(0,0,0,0.3);border-radius:4px;">
                <div>Avg Comp/Prime ratio: <strong>${avgRatio.toFixed(2)}x</strong></div>
                <div>Avg composites in top 10: <strong style="color:#ff6b6b;">${avgCompInTop10.toFixed(1)}/10</strong></div>
            </div>`;

            html += '<div style="font-weight:bold;margin-bottom:4px;">Results by config:</div>';

            for (const r of results) {
                const ratioClass = r.ratio > 1.05 ? 'high' : r.ratio < 0.95 ? 'low' : 'neutral';
                html += `<div class="batch-row">
                    <span class="batch-config">${r.surface}+${r.mapping}</span>
                    <span>
                        <span class="batch-ratio ${ratioClass}">${r.ratio.toFixed(2)}x</span>
                        <span class="batch-top10">(${r.compositesInTop10}C/${r.primesInTop10}P in top10)</span>
                    </span>
                </div>`;
            }

            // Conclusion
            const allTop10Composites = results.reduce((s, r) => s + r.compositesInTop10, 0);
            const totalTop10 = results.length * 10;
            const compPercent = (allTop10Composites / totalTop10 * 100).toFixed(1);

            html += `<div style="margin-top:10px;padding:8px;background:rgba(157,78,221,0.2);border-radius:4px;">
                <div style="color:#9d4edd;font-weight:bold;">üìä CONCLUSION:</div>
                <div>Across ALL configs, <strong style="color:#ff6b6b;">${compPercent}%</strong> of top-10 hub positions are composites</div>
                <div style="font-size:0.6rem;color:#888;margin-top:4px;">
                    (Random expectation with ~11% primes in range: ~89% composites)
                </div>
            </div>`;

            document.getElementById('batchResult').innerHTML = html;
            document.getElementById('batchResult').classList.add('visible');

            btn.textContent = 'üß™ Test All Configs';
            btn.disabled = false;
        }, 100);
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HYPOTHESIS VALIDATION SUITE ‚Äî Event Handlers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getValidationTopK() {
        return parseInt(document.getElementById('validationTopK').value);
    }

    function showValidationResult(html) {
        const el = document.getElementById('validationResult');
        el.innerHTML = html;
        el.style.display = 'block';
    }

    // 1. Base Rate Test
    document.getElementById('baseRateBtn').addEventListener('click', () => {
        const btn = document.getElementById('baseRateBtn');
        btn.textContent = '‚è≥...';
        btn.disabled = true;

        setTimeout(() => {
            explorer.topoAnalyzer.analyze();
            const result = explorer.topoAnalyzer.computeExpectedVsObserved(getValidationTopK());

            const html = `
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:8px;">üìä BASE RATE CORRECTION</div>
                <table style="width:100%;font-size:0.6rem;">
                    <tr><td>Total points:</td><td><strong>${result.totalPoints}</strong></td></tr>
                    <tr><td>Total primes:</td><td><strong>${result.totalPrimes}</strong></td></tr>
                    <tr><td>Prime rate:</td><td><strong>${result.primeRate}</strong></td></tr>
                    <tr><td colspan="2" style="border-top:1px solid #333;padding-top:4px;"></td></tr>
                    <tr><td>Top K tested:</td><td><strong>${result.topK}</strong></td></tr>
                    <tr><td>Expected primes:</td><td><strong>${result.expectedPrimes}</strong></td></tr>
                    <tr><td>Observed primes:</td><td><strong style="color:${result.observedPrimes > parseFloat(result.expectedPrimes) ? '#00ff88' : '#ff6b6b'}">${result.observedPrimes}</strong></td></tr>
                    <tr><td>Deviation:</td><td><strong>${result.deviation} (${result.deviationPercent})</strong></td></tr>
                </table>
                <div style="margin-top:8px;padding:6px;background:rgba(255,107,107,0.2);border-radius:4px;text-align:center;">
                    <strong>${result.direction}</strong>
                </div>
            `;

            showValidationResult(html);
            btn.textContent = 'üìä Base Rate';
            btn.disabled = false;
        }, 50);
    });

    // 2. Permutation Test
    document.getElementById('permTestBtn').addEventListener('click', () => {
        const btn = document.getElementById('permTestBtn');
        btn.textContent = '‚è≥ Running 1000 permutations...';
        btn.disabled = true;

        setTimeout(() => {
            explorer.topoAnalyzer.analyze();
            const result = explorer.topoAnalyzer.permutationTest(getValidationTopK(), 1000);

            const pColor = result.significant ? '#00ff88' : '#ff6b6b';

            const html = `
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:8px;">üé≤ PERMUTATION TEST</div>
                <table style="width:100%;font-size:0.6rem;">
                    <tr><td>Iterations:</td><td><strong>${result.iterations}</strong></td></tr>
                    <tr><td>Top K tested:</td><td><strong>${result.topK}</strong></td></tr>
                    <tr><td colspan="2" style="border-top:1px solid #333;padding-top:4px;"></td></tr>
                    <tr><td>Observed primes:</td><td><strong>${result.observedPrimes}</strong></td></tr>
                    <tr><td>Expected (mean):</td><td><strong>${result.expectedMean}</strong></td></tr>
                    <tr><td>Expected (median):</td><td><strong>${result.expectedMedian}</strong></td></tr>
                    <tr><td>Expected range:</td><td><strong>${result.expectedRange}</strong></td></tr>
                    <tr><td colspan="2" style="border-top:1px solid #333;padding-top:4px;"></td></tr>
                    <tr><td>p-value:</td><td><strong style="color:${pColor}">${result.pValue}</strong></td></tr>
                    <tr><td>Significant (p<0.05)?</td><td><strong style="color:${pColor}">${result.significant ? 'YES' : 'NO'}</strong></td></tr>
                </table>
                <div style="margin-top:8px;padding:6px;background:rgba(${result.significant ? '0,255,136' : '255,107,107'},0.2);border-radius:4px;text-align:center;">
                    <strong>${result.interpretation}</strong>
                </div>
            `;

            showValidationResult(html);
            btn.textContent = 'üé≤ Permutation';
            btn.disabled = false;
        }, 50);
    });

    // 3. N-Scaling Test
    document.getElementById('nScaleBtn').addEventListener('click', () => {
        const btn = document.getElementById('nScaleBtn');
        btn.textContent = '‚è≥ Testing scales...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.topoAnalyzer.nScalingTest(getValidationTopK(), [3000, 5000, 10000, 15000]);

            let tableRows = '';
            for (const r of result.results) {
                const pColor = r.significant ? '#00ff88' : '#ff6b6b';
                tableRows += `<tr>
                    <td>N=${r.maxN}</td>
                    <td>${r.primeRate}</td>
                    <td>${r.expected.toFixed(1)}</td>
                    <td>${r.observed}</td>
                    <td style="color:${pColor}">${r.pValue}</td>
                    <td style="color:${pColor}">${r.significant ? '‚úÖ' : '‚ùå'}</td>
                </tr>`;
            }

            const html = `
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:8px;">üìà N-SCALING TEST</div>
                <table style="width:100%;font-size:0.55rem;border-collapse:collapse;">
                    <tr style="border-bottom:1px solid #333;">
                        <th>N</th><th>œÄ rate</th><th>Exp</th><th>Obs</th><th>p-val</th><th>Sig?</th>
                    </tr>
                    ${tableRows}
                </table>
                <div style="margin-top:8px;padding:6px;background:rgba(${result.significantAtAllScales ? '0,255,136' : '255,107,107'},0.2);border-radius:4px;text-align:center;">
                    <strong>${result.interpretation}</strong>
                </div>
            `;

            showValidationResult(html);
            btn.textContent = 'üìà N-Scaling';
            btn.disabled = false;
        }, 50);
    });

    // 4. Radius Sensitivity Test
    document.getElementById('radiusTestBtn').addEventListener('click', () => {
        const btn = document.getElementById('radiusTestBtn');
        btn.textContent = '‚è≥ Testing radii...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.topoAnalyzer.radiusSensitivityTest(getValidationTopK(), [0.08, 0.12, 0.15, 0.20, 0.25]);

            let tableRows = '';
            for (const r of result.results) {
                const pColor = r.significant ? '#00ff88' : '#ff6b6b';
                tableRows += `<tr>
                    <td>r=${r.radius}</td>
                    <td>${r.expected.toFixed(1)}</td>
                    <td>${r.observed}</td>
                    <td>${r.deviation}</td>
                    <td style="color:${pColor}">${r.pValue}</td>
                    <td style="color:${pColor}">${r.significant ? '‚úÖ' : '‚ùå'}</td>
                </tr>`;
            }

            const html = `
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:8px;">‚≠ï RADIUS SENSITIVITY TEST</div>
                <table style="width:100%;font-size:0.55rem;border-collapse:collapse;">
                    <tr style="border-bottom:1px solid #333;">
                        <th>Radius</th><th>Exp</th><th>Obs</th><th>Dev</th><th>p-val</th><th>Sig?</th>
                    </tr>
                    ${tableRows}
                </table>
                <div style="margin-top:8px;padding:6px;background:rgba(${result.robustAcrossRadii ? '0,255,136' : '255,107,107'},0.2);border-radius:4px;text-align:center;">
                    <strong>${result.interpretation}</strong>
                </div>
            `;

            showValidationResult(html);
            btn.textContent = '‚≠ï Radius Test';
            btn.disabled = false;
        }, 50);
    });

    // 5. FULL VALIDATION SUITE
    document.getElementById('fullValidationBtn').addEventListener('click', () => {
        const btn = document.getElementById('fullValidationBtn');
        btn.textContent = '‚è≥ Running full validation suite...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.topoAnalyzer.runFullValidation(getValidationTopK());

            const verdictColor = result.verdict.testsPassed >= 3 ? '#00ff88' : 
                                 result.verdict.testsPassed >= 2 ? '#ffd93d' : '#ff6b6b';

            const html = `
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:8px;">üî¨ FULL VALIDATION RESULTS</div>
                
                <div style="margin-bottom:8px;padding:6px;background:rgba(0,0,0,0.4);border-radius:4px;font-size:0.55rem;">
                    <div><strong>Config:</strong> ${result.config.surface} + ${result.config.mapping} (${result.config.mappingMode})</div>
                    <div><strong>Max N:</strong> ${result.config.maxN} | <strong>Hub Radius:</strong> ${result.config.hubRadius} | <strong>Top K:</strong> ${result.config.topK}</div>
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">üìä Base Rate:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding-left:8px;">
                    Expected: ${result.tests.baseRate.expectedPrimes} | Observed: ${result.tests.baseRate.observedPrimes} | ${result.tests.baseRate.direction}
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">üé≤ Permutation Test:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding-left:8px;">
                    p-value: <strong style="color:${result.tests.permutation.significant ? '#00ff88' : '#ff6b6b'}">${result.tests.permutation.pValue}</strong> | 
                    ${result.tests.permutation.interpretation}
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">üìà N-Scaling:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding-left:8px;">
                    ${result.tests.nScaling.interpretation}
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">‚≠ï Radius Sensitivity:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding-left:8px;">
                    ${result.tests.radiusSensitivity.interpretation}
                </div>
                
                <div style="margin-top:12px;padding:10px;background:rgba(${verdictColor === '#00ff88' ? '0,255,136' : verdictColor === '#ffd93d' ? '255,217,61' : '255,107,107'},0.25);border-radius:6px;text-align:center;border:2px solid ${verdictColor};">
                    <div style="font-size:1.1rem;font-weight:bold;color:${verdictColor};">${result.verdict.conclusion}</div>
                    <div style="font-size:0.6rem;margin-top:4px;">Tests passed: ${result.verdict.testsPassed}/${result.verdict.testsRun}</div>
                </div>
            `;

            showValidationResult(html);
            showToast(`Validation complete: ${result.verdict.testsPassed}/${result.verdict.testsRun} tests passed`, 
                result.verdict.testsPassed >= 3 ? 'success' : result.verdict.testsPassed >= 2 ? 'info' : 'error');
            btn.textContent = 'üî¨ RUN FULL VALIDATION';
            btn.disabled = false;
        }, 100);
    });

    // Cross-mode validation handler
    document.getElementById('crossModeValidationBtn').addEventListener('click', () => {
        const btn = document.getElementById('crossModeValidationBtn');
        btn.textContent = '‚è≥ Testing across all modes...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.topoAnalyzer.runCrossModeValidation(getValidationTopK());

            const verdictColor = result.summary.significantCount >= 3 ? '#00ff88' : 
                                 result.summary.significantCount >= 1 ? '#ffd93d' : '#ff6b6b';

            // Build mode results table
            let modeRows = '';
            for (const [mode, data] of Object.entries(result.modeResults)) {
                const sigColor = data.significant ? '#00ff88' : '#ff6b6b';
                const enrichment = typeof data.enrichment === 'number' ? data.enrichment : 1;
                const pValue = typeof data.pValue === 'number' ? data.pValue : 1;
                const enrichColor = enrichment > 1.2 ? '#ff6b6b' : enrichment < 0.8 ? '#00ff88' : '#ffd93d';
                modeRows += `
                    <div style="display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid rgba(255,255,255,0.1);">
                        <span style="color:#9d4edd;">${mode}</span>
                        <span>Enrich: <strong style="color:${enrichColor}">${enrichment.toFixed(2)}√ó</strong></span>
                        <span>p: <strong style="color:${sigColor}">${pValue.toFixed(3)}</strong></span>
                    </div>
                `;
            }

            const html = `
                <div style="color:#9d4edd;font-weight:bold;margin-bottom:8px;">üîÑ CROSS-MODE VALIDATION</div>
                
                <div style="margin-bottom:8px;padding:6px;background:rgba(0,0,0,0.4);border-radius:4px;font-size:0.55rem;">
                    <div><strong>Surface:</strong> ${result.config.surface} (${result.config.surfaceType})</div>
                    <div><strong>Mapping:</strong> ${result.config.mapping} | <strong>Max N:</strong> ${result.config.maxN}</div>
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">üìä Results by Mode:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding:4px;background:rgba(0,0,0,0.3);border-radius:4px;">
                    ${modeRows}
                </div>
                
                <div style="font-weight:bold;margin-bottom:4px;">üìà Summary:</div>
                <div style="font-size:0.55rem;margin-bottom:8px;padding-left:8px;">
                    <div>Modes tested: ${result.summary.modesTestedCount}</div>
                    <div>Significant (p<0.05): <strong style="color:${result.summary.significantCount > 0 ? '#00ff88' : '#888'}">${result.summary.significantCount}</strong></div>
                    <div>Avg enrichment: ${result.summary.avgEnrichment.toFixed(2)}√ó</div>
                    <div>Max enrichment: ${result.summary.maxEnrichment.toFixed(2)}√ó (${result.summary.modeWithMaxEnrichment})</div>
                </div>
                
                <div style="margin-top:12px;padding:10px;background:rgba(${verdictColor === '#00ff88' ? '0,255,136' : verdictColor === '#ffd93d' ? '255,217,61' : '255,107,107'},0.25);border-radius:6px;text-align:center;border:2px solid ${verdictColor};">
                    <div style="font-size:1rem;font-weight:bold;color:${verdictColor};">${result.summary.conclusion}</div>
                    <div style="font-size:0.6rem;margin-top:4px;">Significant in: ${result.summary.significantModes.join(', ') || 'none'}</div>
                </div>
            `;

            showValidationResult(html);
            showToast(`Cross-mode: ${result.summary.significantCount}/${result.summary.modesTestedCount} modes significant`, 
                result.summary.significantCount >= 3 ? 'success' : result.summary.significantCount >= 1 ? 'info' : 'error');
            btn.textContent = 'üîÑ CROSS-MODE VALIDATION';
            btn.disabled = false;
        }, 100);
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RESONANCE SPECTRUM ‚Äî Event Handlers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function drawResonanceSpectrum(result) {
        const canvas = document.getElementById('resonanceCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.fillStyle = '#0a0a15';
        ctx.fillRect(0, 0, w, h);

        const spectrum = result.spectrum;
        if (spectrum.length === 0) return;

        const maxDist = Math.max(...spectrum.map(s => s.distance));
        const barWidth = Math.max(1, w / spectrum.length);

        // Draw bars
        for (let i = 0; i < spectrum.length; i++) {
            const s = spectrum[i];
            const barHeight = (s.distance / maxDist) * (h - 20);
            const x = i * barWidth;
            const y = h - 10 - barHeight;

            // Color: factors are highlighted
            if (s.isFactor) {
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x, y - 5, barWidth, barHeight + 5);
                // Draw marker
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, y - 8, barWidth, 3);
            } else {
                ctx.fillStyle = 'rgba(78, 205, 196, 0.6)';
                ctx.fillRect(x, y, barWidth, barHeight);
            }
        }

        // Labels
        ctx.fillStyle = '#888';
        ctx.font = '9px sans-serif';
        ctx.fillText('Prime ‚Üí', 5, h - 2);
        ctx.fillText('Distance ‚Üë', 5, 10);

        // Legend
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(w - 60, 5, 8, 8);
        ctx.fillStyle = '#fff';
        ctx.font = '8px sans-serif';
        ctx.fillText('= Factor', w - 48, 12);
    }

    document.getElementById('computeResonanceBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('resonanceN').value);
        const btn = document.getElementById('computeResonanceBtn');
        btn.textContent = '‚è≥...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.resonanceAnalyzer.computeSpectrum(n);
            const permResult = explorer.resonanceAnalyzer.permutationTest(n, 500);

            drawResonanceSpectrum(result);

            let html = `<div style="color:#9d4edd;font-weight:bold;">N = ${n}</div>`;
            html += `<div>Factors: <strong style="color:#ff6b6b;">${result.factors.join(' √ó ')}</strong></div>`;
            html += `<div>Primes analyzed: ${result.stats.totalPrimes}</div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div>Avg factor distance: <strong>${result.stats.avgFactorDist}</strong></div>`;
            html += `<div>Avg non-factor distance: <strong>${result.stats.avgNonFactorDist}</strong></div>`;
            html += `<div>Ratio: <strong>${result.stats.ratio}</strong></div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div style="font-weight:bold;">Factor Ranks (by proximity):</div>`;
            for (const fr of result.stats.factorRanks) {
                html += `<div>  ${fr.factor}: rank ${fr.rank} (${fr.percentile}%ile)</div>`;
            }

            if (permResult) {
                const pColor = permResult.significant ? '#00ff88' : '#ff6b6b';
                html += `<hr style="border-color:#333;margin:4px 0;">`;
                html += `<div style="color:${pColor};font-weight:bold;">${permResult.interpretation}</div>`;
                html += `<div>p-value: ${permResult.pValue}</div>`;
            }

            document.getElementById('resonanceStats').innerHTML = html;
            document.getElementById('resonanceResult').style.display = 'block';

            btn.textContent = 'üìä Compute Spectrum';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('randomSemiprimeBtn').addEventListener('click', () => {
        const n = explorer.resonanceAnalyzer.randomSemiprime(200);
        document.getElementById('resonanceN').value = n;
        document.getElementById('computeResonanceBtn').click();
    });

    document.getElementById('copyResonanceBtn').addEventListener('click', () => {
        const stats = document.getElementById('resonanceStats').innerText;
        navigator.clipboard.writeText(stats).then(() => {
            showToast('Resonance results copied!', 'success');
        }).catch(() => {
            showToast('Copy failed', 'error');
        });
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEIGHBORHOOD LENS ‚Äî Event Handlers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    document.getElementById('neighborRadius').addEventListener('input', e => {
        document.getElementById('neighborRadiusValue').textContent = e.target.value;
    });

    document.getElementById('analyzeNeighborhoodBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('neighborhoodN').value);
        const radius = parseFloat(document.getElementById('neighborRadius').value);
        const btn = document.getElementById('analyzeNeighborhoodBtn');
        btn.textContent = '‚è≥...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.neighborhoodAnalyzer.analyze(n, radius);

            let html = `<div style="color:#4ecdc4;font-weight:bold;">N = ${n}</div>`;
            html += `<div>Factors: <strong style="color:#ff6b6b;">${result.factors.join(' √ó ')}</strong></div>`;
            html += `<div>Search radius: ${radius}</div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div>Primes in neighborhood: <strong>${result.stats.totalNeighbors}</strong></div>`;
            html += `<div>Factors found: <strong style="color:${result.stats.factorsInNeighborhood > 0 ? '#00ff88' : '#ff6b6b'};">${result.stats.factorsInNeighborhood}/${result.factors.length}</strong></div>`;
            html += `<div>Expected if random: ${result.stats.expectedIfRandom}</div>`;
            html += `<div>Enrichment: <strong>${result.stats.enrichment}</strong></div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div style="font-weight:bold;">Factor positions:</div>`;
            for (const fp of result.stats.factorPositions) {
                const color = fp.position === 'NOT IN NEIGHBORHOOD' ? '#ff6b6b' : '#00ff88';
                html += `<div style="color:${color};">  ${fp.factor}: ${fp.position}</div>`;
            }

            if (result.neighbors.length > 0) {
                html += `<hr style="border-color:#333;margin:4px 0;">`;
                html += `<div style="font-weight:bold;">Nearest primes:</div>`;
                for (let i = 0; i < Math.min(5, result.neighbors.length); i++) {
                    const nb = result.neighbors[i];
                    const marker = nb.isFactor ? ' ‚≠ê' : '';
                    html += `<div>  ${nb.prime}: d=${nb.distance.toFixed(4)}${marker}</div>`;
                }
            }

            document.getElementById('neighborhoodResult').innerHTML = html;
            document.getElementById('neighborhoodResult').style.display = 'block';
            document.getElementById('copyNeighborhoodBtn').style.display = 'block';

            btn.textContent = 'üîç Analyze';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('highlightFactorsBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('neighborhoodN').value);
        const factors = explorer.resonanceAnalyzer.factor(n);

        // Find and highlight points
        explorer.selectedPoint = explorer.points.find(p => p.n === n);

        showToast(`Factors of ${n}: ${factors.join(' √ó ')}`, 'info');
    });

    document.getElementById('copyNeighborhoodBtn').addEventListener('click', () => {
        const stats = document.getElementById('neighborhoodResult').innerText;
        navigator.clipboard.writeText(stats).then(() => {
            showToast('Neighborhood results copied!', 'success');
        }).catch(() => {
            showToast('Copy failed', 'error');
        });
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONSTRAINT VISUALIZER ‚Äî Event Handlers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    document.getElementById('constraintStrength').addEventListener('input', e => {
        document.getElementById('constraintStrengthValue').textContent = e.target.value + '%';
    });

    document.getElementById('showConstraintBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('constraintN').value);
        const type = document.getElementById('constraintType').value;
        const strength = parseInt(document.getElementById('constraintStrength').value);
        const btn = document.getElementById('showConstraintBtn');
        btn.textContent = '‚è≥...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.constraintVisualizer.getCandidates(n, type, strength);

            let html = `<div style="color:#ffd93d;font-weight:bold;">N = ${n}</div>`;
            html += `<div>Factors: <strong style="color:#ff6b6b;">${result.factors.join(' √ó ')}</strong></div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div>${result.constraintDesc}</div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div>Full search space: <strong>${result.allPrimesCount}</strong> primes</div>`;
            html += `<div>After constraint: <strong style="color:#00ff88;">${result.candidatesCount}</strong> candidates</div>`;
            html += `<div>Reduction: <strong style="color:#ffd93d;">${result.reduction}</strong></div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;

            const factorsOK = result.factorsInCandidates;
            html += `<div style="color:${factorsOK ? '#00ff88' : '#ff6b6b'};">`;
            html += factorsOK ? '‚úÖ Actual factors ARE in candidate set!' : '‚ùå Factors NOT in candidates (constraint too strong)';
            html += '</div>';

            if (result.candidatesCount <= 20) {
                html += `<hr style="border-color:#333;margin:4px 0;">`;
                html += `<div style="font-weight:bold;">Candidates:</div>`;
                html += `<div style="word-break:break-all;">${result.candidates.join(', ')}</div>`;
            }

            document.getElementById('constraintResult').innerHTML = html;
            document.getElementById('constraintResult').style.display = 'block';
            document.getElementById('copyConstraintBtn').style.display = 'block';

            // Highlight candidates on visualization
            explorer.constraintVisualizer.highlightCandidates(result.candidates);

            showToast(`${result.candidatesCount} candidates (${result.reduction})`, 'info');

            btn.textContent = 'üìê Visualize';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('copyConstraintBtn').addEventListener('click', () => {
        const stats = document.getElementById('constraintResult').innerText;
        navigator.clipboard.writeText(stats).then(() => {
            showToast('Constraint results copied!', 'success');
        }).catch(() => {
            showToast('Copy failed', 'error');
        });
    });

    document.getElementById('animateConstraintBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('constraintN').value);
        const type = document.getElementById('constraintType').value;
        const slider = document.getElementById('constraintStrength');
        const btn = document.getElementById('animateConstraintBtn');

        if (type === 'none') {
            alert('Select a constraint type first!');
            return;
        }

        btn.disabled = true;
        btn.textContent = '‚ñ∂Ô∏è Running...';

        let strength = 0;
        const animate = () => {
            slider.value = strength;
            document.getElementById('constraintStrengthValue').textContent = strength + '%';
            document.getElementById('showConstraintBtn').click();

            strength += 10;
            if (strength <= 100) {
                setTimeout(animate, 500);
            } else {
                btn.textContent = '‚ñ∂Ô∏è Animate';
                btn.disabled = false;
            }
        };

        animate();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ERROR VECTOR EXPLORER ‚Äî Event Handlers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function drawErrorPlot(data) {
        const canvas = document.getElementById('errorCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.fillStyle = '#0a0a15';
        ctx.fillRect(0, 0, w, h);

        if (data.length === 0) return;

        const maxX = Math.max(...data.map(d => d.x));
        const maxY = Math.max(...data.map(d => d.y));

        // Draw points
        for (const d of data) {
            const x = 10 + (d.x / maxX) * (w - 20);
            const y = h - 10 - (d.y / maxY) * (h - 20);

            // Color by ratio
            const hue = Math.min(d.ratio * 30, 120);
            ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Axes labels
        ctx.fillStyle = '#888';
        ctx.font = '9px sans-serif';
        ctx.fillText('N ‚Üí', w - 25, h - 2);
        ctx.fillText('Error ‚Üë', 5, 10);
    }

    document.getElementById('computeErrorsBtn').addEventListener('click', () => {
        const sampleSize = parseInt(document.getElementById('errorSampleSize').value);
        const btn = document.getElementById('computeErrorsBtn');
        btn.textContent = '‚è≥ Computing...';
        btn.disabled = true;

        setTimeout(() => {
            explorer.errorVectorAnalyzer.batchCompute(sampleSize);

            document.getElementById('errorStats').innerHTML = `<div style="color:#00ff88;">‚úÖ Computed ${sampleSize} error vectors</div><div>Click "Plot" or "Find Correlations" to analyze.</div>`;
            document.getElementById('errorResult').style.display = 'block';

            btn.textContent = 'üìä Compute Errors';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('plotErrorsBtn').addEventListener('click', () => {
        const data = explorer.errorVectorAnalyzer.getPlotData();

        if (data.length === 0) {
            alert('Compute errors first!');
            return;
        }

        drawErrorPlot(data);
        document.getElementById('errorResult').style.display = 'block';
    });

    document.getElementById('errorCorrelationBtn').addEventListener('click', () => {
        const btn = document.getElementById('errorCorrelationBtn');
        btn.textContent = '‚è≥...';
        btn.disabled = true;

        setTimeout(() => {
            const result = explorer.errorVectorAnalyzer.analyzeCorrelations();

            let html = `<div style="color:#00ff88;font-weight:bold;">Correlation Analysis</div>`;
            html += `<div>Sample size: ${result.sampleSize}</div>`;
            html += `<div>Avg error: ${result.avgError}</div>`;
            html += `<div>Range: ${result.minError} - ${result.maxError}</div>`;
            html += `<hr style="border-color:#333;margin:4px 0;">`;
            html += `<div style="font-weight:bold;">Correlations (r):</div>`;

            for (const [key, val] of Object.entries(result.correlations)) {
                const absR = Math.abs(parseFloat(val.r));
                const color = absR > 0.5 ? '#00ff88' : absR > 0.3 ? '#ffd93d' : '#888';
                html += `<div style="color:${color};">  ${val.meaning}: <strong>${val.r}</strong></div>`;
            }

            html += `<hr style="border-color:#333;margin:4px 0;">`;
            const strongest = result.strongestCorrelation;
            if (Math.abs(strongest.value) > 0.3) {
                html += `<div style="color:#00ff88;font-weight:bold;">‚ö° Strongest: ${strongest.key} (r=${strongest.value.toFixed(3)})</div>`;
            } else {
                html += `<div style="color:#888;">No strong correlations found (|r| < 0.3)</div>`;
            }

            document.getElementById('errorStats').innerHTML = html;
            document.getElementById('errorResult').style.display = 'block';

            btn.textContent = 'üîó Find Correlations';
            btn.disabled = false;
        }, 50);
    });

    document.getElementById('copyErrorBtn').addEventListener('click', () => {
        const stats = document.getElementById('errorStats').innerText;
        navigator.clipboard.writeText(stats).then(() => {
            showToast('Error analysis copied!', 'success');
        }).catch(() => {
            showToast('Copy failed', 'error');
        });
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Toast Notification System
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function showToast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        const icons = { success: '‚úÖ', error: '‚ùå', info: 'üí°' };
        toast.innerHTML = `<span>${icons[type] || 'üí°'}</span><span>${message}</span>`;

        container.appendChild(toast);

        // Remove after animation
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }

    // Make toast globally available
    window.showToast = showToast;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Keyboard Shortcuts
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.addEventListener('keydown', e => {
        // Don't trigger if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

        switch(e.key.toLowerCase()) {
            case 'r':
                explorer.autoRotate = !explorer.autoRotate;
                document.getElementById('btnRotate').classList.toggle('active', explorer.autoRotate);
                document.getElementById('spinToggleBtn').classList.toggle('active', explorer.autoRotate);
                showToast(`Auto-rotate ${explorer.autoRotate ? 'ON' : 'OFF'}`, 'info');
                break;
            case '+':
            case '=':
                explorer.zoomIn();
                break;
            case '-':
                explorer.zoomOut();
                break;
            case 'arrowup':
                e.preventDefault();
                explorer.panUp();
                break;
            case 'arrowdown':
                e.preventDefault();
                explorer.panDown();
                break;
            case 'arrowleft':
                e.preventDefault();
                explorer.panLeft();
                break;
            case 'arrowright':
                e.preventDefault();
                explorer.panRight();
                break;
            case 'c':
                explorer.centerView();
                showToast('View centered', 'success');
                break;
            case '0':
                explorer.resetView();
                showToast('View reset', 'success');
                break;
            case 'w':
                explorer.showWireframe = !explorer.showWireframe;
                document.getElementById('btnWireframe').classList.toggle('active', explorer.showWireframe);
                showToast(`Wireframe ${explorer.showWireframe ? 'ON' : 'OFF'}`, 'info');
                break;
            case 'p':
                explorer.showPrimes = !explorer.showPrimes;
                document.getElementById('btnPrimes').classList.toggle('active', explorer.showPrimes);
                showToast(`Primes ${explorer.showPrimes ? 'visible' : 'hidden'}`, 'info');
                break;
            case '?':
            case 'h':
                showToast('Keys: R=rotate, +/-=zoom, ‚Üë‚Üì‚Üê‚Üí=pan, C=center, 0=reset, W=wire, P=primes', 'info');
                break;
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Initialize
    explorer.init();
    explorer._updateSurfaceInfo();

    // iOS Safari: Resize again after a short delay to fix canvas sizing
    setTimeout(() => {
        explorer.renderer.resize();
    }, 250);

    // Also resize on orientation change (mobile)
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            explorer.renderer.resize();
        }, 300);
    });

    // NEW: View control buttons
    document.getElementById('zoomInBtn').addEventListener('click', () => explorer.zoomIn());
    document.getElementById('zoomOutBtn').addEventListener('click', () => explorer.zoomOut());
    document.getElementById('centerViewBtn').addEventListener('click', () => explorer.centerView());
    document.getElementById('resetViewBtn').addEventListener('click', () => explorer.resetView());
    document.getElementById('panUpBtn').addEventListener('click', () => explorer.panUp());
    document.getElementById('panDownBtn').addEventListener('click', () => explorer.panDown());
    document.getElementById('panLeftBtn').addEventListener('click', () => explorer.panLeft());
    document.getElementById('panRightBtn').addEventListener('click', () => explorer.panRight());
    document.getElementById('viewTopBtn').addEventListener('click', () => explorer.viewFromTop());
    document.getElementById('viewBottomBtn').addEventListener('click', () => explorer.viewFromBottom());
    document.getElementById('viewSideBtn').addEventListener('click', () => explorer.viewFromSide());
    document.getElementById('spinToggleBtn').addEventListener('click', e => {
        explorer.autoRotate = !explorer.autoRotate;
        e.target.classList.toggle('active', explorer.autoRotate);
        // Also sync the other spin button if it exists
        const btnRotate = document.getElementById('btnRotate');
        if (btnRotate) btnRotate.classList.toggle('active', explorer.autoRotate);
    });

    // Sync the panel Spin button with the overlay button
    const originalRotateBtn = document.getElementById('btnRotate');
    if (originalRotateBtn) {
        const originalHandler = originalRotateBtn.onclick;
        originalRotateBtn.addEventListener('click', () => {
            document.getElementById('spinToggleBtn').classList.toggle('active', explorer.autoRotate);
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EC MODE EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.getElementById('ecModeEnabled').addEventListener('change', e => {
        explorer.ecMode.enabled = e.target.checked;
        if (e.target.checked) {
            const curveLabel = document.getElementById('ecCurveSelect').value;
            explorer.ecMode.setCurve(curveLabel);
            explorer.bsdViz.setCurve(curveLabel);
            document.getElementById('ecInfoPanel').style.display = 'block';
            document.getElementById('ecInfoPanel').innerHTML = explorer.ecMode.getBSDInfo();
            document.getElementById('bsdSection').style.display = 'block';
            showToast(`EC Mode: ${curveLabel} loaded`, 'info');
        } else {
            document.getElementById('ecInfoPanel').style.display = 'none';
            document.getElementById('bsdSection').style.display = 'none';
        }
        explorer.generatePoints();
    });

    document.getElementById('ecCurveSelect').addEventListener('change', e => {
        explorer.ecMode.setCurve(e.target.value);
        explorer.bsdViz.setCurve(e.target.value);
        if (explorer.ecMode.enabled) {
            document.getElementById('ecInfoPanel').innerHTML = explorer.ecMode.getBSDInfo();
            explorer.generatePoints();
            showToast(`Loaded curve: ${e.target.value}`, 'success');
        }
    });

    document.getElementById('ecFilterSelect').addEventListener('change', e => {
        explorer.ecMode.filter = e.target.value;
        if (explorer.ecMode.enabled) {
            showToast(`Filter: ${e.target.value}`, 'info');
            // Force re-render to apply filter
            explorer.generatePoints();
        }
    });

    document.getElementById('ecStatsBtn').addEventListener('click', () => {
        if (!explorer.ecMode.enabled || !explorer.ecMode.currentCurve) { alert('Enable EC Mode first!'); return; }
        const stats = explorer.ecMode.getStatistics(explorer.maxN);
        let html = `<div style="color:#5096ff;font-weight:bold;">üìä ${stats.curve} Statistics</div>`;
        html += `<div>Rank: ${stats.rank} | Sha: ${stats.sha}</div>`;
        html += `<div>üî¥ Bad: ${stats.badPrimes.join(', ')}</div>`;
        html += `<div>üîµ Supersingular: ${stats.supersingular.length}</div>`;
        html += `<div>üü° Ordinary: ${stats.ordinary.length}</div>`;
        if (stats.sha > 1) html += `<div style="color:${stats.shaTestCandidates.length > 0 ? '#00ff88' : '#ff6b6b'};">Sha tests: ${stats.shaTestCandidates.length > 0 ? stats.shaTestCandidates.join(', ') : 'None (bad reduction)'}</div>`;
        document.getElementById('ecInfoPanel').innerHTML = html;
        document.getElementById('ecInfoPanel').style.display = 'block';
    });

    document.getElementById('ecCompareBtn').addEventListener('click', () => {
        const result = explorer.ecMode.compareCurves(Object.keys(CURVE_DATABASE), Math.min(explorer.maxN, 200));
        if (!result) return;
        let html = `<div style="color:#5096ff;font-weight:bold;">üîÑ Cross-Curve Comparison</div>`;
        html += `<div>Common SS: ${result.commonSS.length > 0 ? result.commonSS.join(', ') : 'None'}</div>`;
        html += `<div>Never SS: ${result.neverSS.slice(0, 15).join(', ')}...</div>`;
        document.getElementById('ecInfoPanel').innerHTML = html;
        document.getElementById('ecInfoPanel').style.display = 'block';
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BSD VISUALIZATION EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.getElementById('showBSDBtn').addEventListener('click', () => {
        if (!explorer.bsdViz.currentCurve) {
            const curveLabel = document.getElementById('ecCurveSelect').value;
            explorer.bsdViz.setCurve(curveLabel);
        }
        document.getElementById('bsdFormulaContainer').innerHTML = explorer.bsdViz.getFormulaHTML();
        document.getElementById('shaExplanationContainer').innerHTML = '';
        document.getElementById('lFunctionContainer').innerHTML = '';
        showToast('BSD formula displayed', 'success');
    });

    document.getElementById('showShaBtn').addEventListener('click', () => {
        if (!explorer.bsdViz.currentCurve) {
            const curveLabel = document.getElementById('ecCurveSelect').value;
            explorer.bsdViz.setCurve(curveLabel);
        }
        document.getElementById('shaExplanationContainer').innerHTML = explorer.bsdViz.getShaExplanationHTML();
        document.getElementById('bsdFormulaContainer').innerHTML = '';
        document.getElementById('lFunctionContainer').innerHTML = '';
        const curve = explorer.bsdViz.currentCurve;
        if (curve && curve.sha > 1) {
            showToast(`Sha = ${curve.sha} = ${Math.sqrt(curve.sha)}¬≤ structure shown`, 'info');
        } else {
            showToast('Sha is trivial for this curve', 'info');
        }
    });

    document.getElementById('animateLBtn').addEventListener('click', () => {
        if (!explorer.bsdViz.currentCurve) {
            const curveLabel = document.getElementById('ecCurveSelect').value;
            explorer.bsdViz.setCurve(curveLabel);
        }

        // Stop any running animation
        explorer.bsdViz.stopAnimation();

        document.getElementById('bsdFormulaContainer').innerHTML = '';
        document.getElementById('shaExplanationContainer').innerHTML = '';

        // Initialize and run the new step-by-step animation
        if (explorer.bsdViz.initAnimation('lFunctionContainer')) {
            const btn = document.getElementById('animateLBtn');
            const originalText = btn.textContent;
            btn.textContent = '‚èπ Stop';
            btn.style.background = 'rgba(255,107,107,0.2)';

            explorer.bsdViz.runAnimation(180, (info) => {
                if (info.done) {
                    btn.textContent = originalText;
                    btn.style.background = 'rgba(255,217,61,0.2)';
                    const interp = explorer.bsdViz.getInterpretation();
                    showToast(info.target ? `Final: ${info.product.toFixed(4)} vs target ${info.target.toFixed(4)}` : 'Animation complete', 'success');
                    // Add interpretation below
                    const container = document.getElementById('lFunctionContainer');
                    if (container) {
                        container.innerHTML += `<div style="margin-top:8px;padding:8px;background:rgba(78,205,196,0.1);border-radius:4px;font-size:0.5rem;color:#aaa;border-left:3px solid #4ecdc4;">${interp}</div>`;
                    }
                }
            });

            showToast('L-function buildup animating step by step...', 'info');
        } else {
            showToast('Select a curve first', 'error');
        }
    });

    document.getElementById('colorByLBtn').addEventListener('click', () => {
        if (!explorer.bsdViz.currentCurve) {
            const curveLabel = document.getElementById('ecCurveSelect').value;
            explorer.bsdViz.setCurve(curveLabel);
        }
        // Color points by L-function contribution
        explorer.points.forEach(p => {
            if (p.isPrime) {
                const lColor = explorer.bsdViz.getLContributionColor(p.n);
                if (lColor) {
                    p.color = lColor;
                    p.hex = `rgb(${lColor.r},${lColor.g},${lColor.b})`;
                }
            }
        });
        showToast('Primes colored by L-contribution: red=increases, blue=decreases', 'success');
    });

    // EC FRONTIER EXPERIMENT HANDLERS
    document.getElementById('runFrontierBtn').addEventListener('click', () => {
        const btn = document.getElementById('runFrontierBtn');
        btn.textContent = '‚è≥ Running...'; btn.disabled = true;
        setTimeout(() => {
            const results = explorer.frontierExp.runFullExperiment(parseInt(document.getElementById('frontierSampleSize').value));
            let html = `<div style="color:#00ff88;font-weight:bold;">üî¨ FRONTIER RESULTS</div>`;
            html += `<div style="font-size:0.5rem;">${results.timestamp}</div>`;
            for (const [curve, analysis] of Object.entries(results.tests.ecAdditivity)) {
                if (!analysis) continue;
                html += `<div><span style="color:#4ecdc4;">${curve}:</span> r=${analysis.correlationWithSum}</div>`;
            }
            html += `<div style="margin-top:8px;padding:6px;background:rgba(${results.verdict.conclusion.includes('SIGNAL') ? '0,255,136' : '255,107,107'},0.2);border-radius:4px;text-align:center;font-weight:bold;">${results.verdict.conclusion}</div>`;
            document.getElementById('frontierResult').innerHTML = html;
            document.getElementById('frontierResult').style.display = 'block';
            showToast(`FRONTIER: ${results.verdict.conclusion}`, results.verdict.conclusion.includes('SIGNAL') ? 'success' : 'info');
            btn.textContent = 'üî¨ RUN FRONTIER EXPERIMENT'; btn.disabled = false;
        }, 100);
    });

    document.getElementById('testSemiprimeECBtn').addEventListener('click', () => {
        const p = parseInt(document.getElementById('frontierP').value);
        const q = parseInt(document.getElementById('frontierQ').value);
        if (!p || !q || !PrimeMath.isPrime(p) || !PrimeMath.isPrime(q)) { alert('Enter two primes!'); return; }
        const revealing = explorer.semiprimeEC.findRevealingCurves(p * q, p, q);
        let html = `<div style="color:#00ff88;font-weight:bold;">${p * q} = ${p} √ó ${q}</div>`;
        html += revealing.length === 0 ? `<div style="color:#ff6b6b;">No revealing curves</div>` :
            revealing.map(r => `<div>${r.curve}: err=${r.relErrorSum.toFixed(4)}</div>`).join('');
        document.getElementById('frontierResult').innerHTML = html;
        document.getElementById('frontierResult').style.display = 'block';
    });

    document.getElementById('groupStructureBtn').addEventListener('click', () => {
        const p = parseInt(document.getElementById('frontierP').value);
        const q = parseInt(document.getElementById('frontierQ').value);
        if (!p || !q) { alert('Enter p and q!'); return; }
        const analysis = explorer.groupAnalyzer.detectProductStructure(p * q);
        let html = `<div style="color:#00ff88;font-weight:bold;">(‚Ñ§/${p*q}‚Ñ§)* Structure</div>`;
        html += `<div>œÜ(n) = ${analysis.phiN} = ${analysis.phiP} √ó ${analysis.phiQ}</div>`;
        html += `<div style="color:${analysis.structureVisible ? '#00ff88' : '#ff6b6b'};">${analysis.structureVisible ? '‚ö†Ô∏è PARTIALLY VISIBLE' : '‚úì HIDDEN'}</div>`;
        document.getElementById('frontierResult').innerHTML = html;
        document.getElementById('frontierResult').style.display = 'block';
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ORDER/GCD TELEMETRY EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.getElementById('orderBound').addEventListener('input', e => {
        document.getElementById('orderBoundValue').textContent = e.target.value;
    });

    document.getElementById('runOrderAttackBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('orderTargetN').value);
        if (!n || n < 4) { alert('Enter a composite number n ‚â• 4'); return; }
        if (PrimeMath.isPrime(n)) { alert(`${n} is prime! Enter a composite.`); return; }

        const bound = parseInt(document.getElementById('orderBound').value);
        const heuristic = document.getElementById('orderHeuristic').value;

        document.getElementById('orderProgress').style.display = 'block';
        document.getElementById('orderProgressBar').style.width = '0%';

        // Run with animation
        const btn = document.getElementById('runOrderAttackBtn');
        btn.disabled = true;
        btn.textContent = '‚è≥ Running...';

        setTimeout(() => {
            const result = explorer.orderGCD.runAttack(n, bound, heuristic);

            document.getElementById('orderProgressBar').style.width = '100%';

            let html = '';
            if (result.success) {
                html = `<div style="color:#00ff88;font-weight:bold;">‚úÖ FACTOR FOUND!</div>`;
                html += `<div style="font-size:1.1rem;margin:6px 0;">${result.n} = <span style="color:#ffb432;">${result.factor}</span> √ó ${result.otherFactor}</div>`;
                html += `<div>Found at k = ${result.foundAtK} (${result.heuristic})</div>`;
                html += `<div>GCD checks: ${result.gcdChecks} | Time: ${result.timeMs}ms</div>`;

                // Enhanced smoothness analysis
                const smooth = result.smoothness;
                const pMinus1 = result.factor - 1;
                const qMinus1 = result.otherFactor - 1;
                html += `<div style="margin-top:8px;padding:8px;background:rgba(0,255,136,0.1);border-radius:4px;border:1px solid rgba(0,255,136,0.3);">`;
                html += `<div style="font-weight:bold;color:#00ff88;margin-bottom:4px;">Why Pollard p-1 worked:</div>`;
                html += `<div style="font-size:0.55rem;">`;
                html += `<div>p - 1 = ${pMinus1} = ${factorizeDisplay(pMinus1)}</div>`;
                html += `<div><span class="smoothness-indicator smooth">${smooth.bound}-smooth</span></div>`;
                html += `<div style="margin-top:4px;">q - 1 = ${qMinus1} = ${factorizeDisplay(qMinus1)}</div>`;
                html += `<div style="margin-top:4px;color:#aaa;">Since (p-1) divides ${result.foundAtK}!, we have a<sup>${result.foundAtK}!</sup> ‚â° 1 (mod p)</div>`;
                html += `<div style="color:#aaa;">Therefore gcd(a<sup>${result.foundAtK}!</sup> - 1, n) = p ‚úì</div>`;
                html += `</div></div>`;

                showToast(`Factor found: ${result.factor} (${smooth.bound}-smooth)`, 'success');

                // Auto-show smoothness analysis
                document.getElementById('smoothnessAnalysis').style.display = 'block';
                document.getElementById('smoothnessContent').innerHTML = `
                    <div>p = ${result.factor} ‚Üí p-1 = ${pMinus1}</div>
                    <div>Factorization: ${factorizeDisplay(pMinus1)}</div>
                    <div>Largest prime factor: <span style="color:#00ff88;">${smooth.bound}</span></div>
                    <div style="margin-top:4px;color:#888;">Attack needed k ‚â• ${smooth.bound} to succeed</div>
                `;
            } else {
                html = `<div style="color:#ff6b6b;font-weight:bold;">‚ùå NO FACTOR FOUND</div>`;
                html += `<div>${result.reason}</div>`;
                html += `<div>GCD checks: ${result.gcdChecks} | Time: ${result.timeMs}ms</div>`;

                // Explanation for failure
                html += `<div style="margin-top:8px;padding:8px;background:rgba(255,107,107,0.1);border-radius:4px;border:1px solid rgba(255,107,107,0.3);">`;
                html += `<div style="font-weight:bold;color:#ff6b6b;margin-bottom:4px;">Why Pollard p-1 failed:</div>`;
                html += `<div style="font-size:0.55rem;color:#aaa;">`;
                html += `<div>Both (p-1) and (q-1) likely have prime factors > ${bound}</div>`;
                html += `<div style="margin-top:4px;">Options:</div>`;
                html += `<div>‚Ä¢ Increase bound (try ${bound * 2} or higher)</div>`;
                html += `<div>‚Ä¢ Try a different heuristic</div>`;
                html += `<div>‚Ä¢ This may be an RSA-style semiprime (resistant by design)</div>`;
                html += `</div></div>`;

                showToast('No factor found ‚Äî try increasing bound', 'info');
                document.getElementById('smoothnessAnalysis').style.display = 'none';
            }

            document.getElementById('orderResultContent').innerHTML = html;
            document.getElementById('orderResult').style.display = 'block';

            // Update history
            updateOrderHistory();

            btn.disabled = false;
            btn.textContent = '‚ñ∂ Run Attack';
        }, 50);
    });

    document.getElementById('stepOrderAttackBtn').addEventListener('click', () => {
        const n = parseInt(document.getElementById('orderTargetN').value);

        if (!explorer.orderGCD.stepMode) {
            // Initialize step mode
            if (!n || n < 4) { alert('Enter a composite number n ‚â• 4'); return; }
            if (PrimeMath.isPrime(n)) { alert(`${n} is prime!`); return; }

            const heuristic = document.getElementById('orderHeuristic').value;
            explorer.orderGCD.initStepMode(n, heuristic);

            document.getElementById('orderProgress').style.display = 'block';
            document.getElementById('orderCurrentK').textContent = '1';
            document.getElementById('orderGcdChecks').textContent = '0';
            document.getElementById('orderProgressBar').style.width = '0%';

            document.getElementById('orderResultContent').innerHTML = `<div style="color:#ffb432;">Step mode initialized. Click ‚è≠ to advance.</div>`;
            document.getElementById('orderResult').style.display = 'block';

            document.getElementById('stepOrderAttackBtn').textContent = '‚è≠ Step';
            showToast('Step mode started', 'info');
        } else {
            // Execute one step
            const stepResult = explorer.orderGCD.step();
            if (!stepResult) return;

            const bound = parseInt(document.getElementById('orderBound').value);
            const progress = (stepResult.k / bound) * 100;

            document.getElementById('orderCurrentK').textContent = stepResult.k;
            document.getElementById('orderGcdChecks').textContent = stepResult.k - 1;
            document.getElementById('orderProgressBar').style.width = Math.min(progress, 100) + '%';

            if (stepResult.status === 'found') {
                const r = stepResult.result;
                let html = `<div style="color:#00ff88;font-weight:bold;">‚úÖ FACTOR FOUND!</div>`;
                html += `<div style="font-size:1.1rem;">${r.n} = <span style="color:#ffb432;">${r.factor}</span> √ó ${r.otherFactor}</div>`;
                html += `<div>Found at k = ${r.foundAtK}</div>`;
                document.getElementById('orderResultContent').innerHTML = html;

                document.getElementById('stepOrderAttackBtn').textContent = '‚è≠ Step';
                updateOrderHistory();
                showToast(`Factor found at k=${r.foundAtK}!`, 'success');
            } else {
                document.getElementById('orderResultContent').innerHTML = 
                    `<div>k = ${stepResult.k} | gcd = ${stepResult.gcd === '1' ? '<span style="color:#888;">1</span>' : `<span style="color:#ffb432;">${stepResult.gcd}</span>`}</div>`;

                if (stepResult.k >= bound) {
                    explorer.orderGCD.stepMode = false;
                    document.getElementById('orderResultContent').innerHTML += 
                        `<div style="color:#ff6b6b;margin-top:6px;">Bound reached. No factor found.</div>`;
                    showToast('Bound reached, no factor', 'info');
                }
            }
        }
    });

    document.getElementById('randomSmoothBtn').addEventListener('click', () => {
        const test = explorer.orderGCD.generateSmoothSemiprime();
        document.getElementById('orderTargetN').value = test.n;

        let html = `<div style="color:#00ff88;">üé≤ Generated: ${test.n} = ${test.p} √ó ${test.q}</div>`;
        html += `<div style="color:#888;font-size:0.55rem;">${test.note}</div>`;
        html += `<div style="color:#00ff88;margin-top:4px;">This SHOULD be easy to factor!</div>`;
        document.getElementById('orderResultContent').innerHTML = html;
        document.getElementById('orderResult').style.display = 'block';

        explorer.orderGCD.stepMode = false;
        showToast(`Smooth semiprime: ${test.n}`, 'success');
    });

    document.getElementById('randomHardBtn').addEventListener('click', () => {
        const test = explorer.orderGCD.generateHardSemiprime();
        document.getElementById('orderTargetN').value = test.n;

        let html = `<div style="color:#ff6b6b;">üé≤ Generated: ${test.n} = ${test.p} √ó ${test.q}</div>`;
        html += `<div style="color:#888;font-size:0.55rem;">${test.note}</div>`;
        html += `<div style="color:#ff6b6b;margin-top:4px;">This SHOULD resist the attack!</div>`;
        document.getElementById('orderResultContent').innerHTML = html;
        document.getElementById('orderResult').style.display = 'block';

        explorer.orderGCD.stepMode = false;
        showToast(`Hard semiprime: ${test.n}`, 'info');
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // POLLARD P-1 VISUALIZATION HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    document.getElementById('showTimelineBtn').addEventListener('click', () => {
        const history = explorer.orderGCD.history;
        if (history.length === 0) {
            showToast('Run an attack first to see timeline', 'info');
            return;
        }

        const latest = history[0];
        let html = '';

        if (latest.success) {
            // Show the attack progression
            const steps = Math.min(latest.foundAtK, 20);
            for (let k = 2; k <= steps; k++) {
                const isFound = k === latest.foundAtK;
                html += `<div class="pollard-step ${isFound ? 'found' : ''}">
                    <span class="pollard-k">k=${k}</span>
                    <span>a^(${latest.heuristic === 'factorial' ? k + '!' : 'exp'}) mod n</span>
                    <span class="pollard-gcd ${isFound ? 'factor' : 'trivial'}">${isFound ? '‚Üí gcd = ' + latest.factor + ' üéâ' : 'gcd = 1'}</span>
                </div>`;
            }
            // Show smoothness analysis
            const pMinus1 = latest.factor - 1;
            html += `<div style="margin-top:8px;padding:6px;background:rgba(0,255,136,0.1);border-radius:4px;">
                <div style="color:#00ff88;font-weight:bold;">Why it worked:</div>
                <div>p - 1 = ${pMinus1}</div>
                <div>= ${factorizeDisplay(pMinus1)}</div>
                <div class="smoothness-indicator smooth">${latest.smoothness?.bound || '?'}-smooth</div>
            </div>`;
        } else {
            html = `<div style="color:#ff6b6b;padding:8px;">Attack failed after ${latest.gcdChecks} GCD checks.<br>Try increasing bound or use a smooth semiprime.</div>`;
        }

        document.getElementById('pollardTimelineContent').innerHTML = html;
        document.getElementById('pollardTimeline').style.display = 'block';
        showToast('Timeline displayed', 'success');
    });

    document.getElementById('compareSmoothnessBtn').addEventListener('click', () => {
        // Generate both smooth and hard examples
        const smooth = explorer.orderGCD.generateSmoothSemiprime();
        const hard = explorer.orderGCD.generateHardSemiprime();

        // Show smoothness comparison
        const smoothP1 = smooth.p - 1;
        const smoothQ1 = smooth.q - 1;
        const hardP1 = hard.p - 1;
        const hardQ1 = hard.q - 1;

        document.getElementById('smoothExample').innerHTML = `
            <div>${smooth.n} = ${smooth.p} √ó ${smooth.q}</div>
            <div style="margin-top:4px;">p-1 = ${smoothP1}</div>
            <div>= ${factorizeDisplay(smoothP1)}</div>
            <div style="margin-top:2px;">q-1 = ${smoothQ1}</div>
            <div>= ${factorizeDisplay(smoothQ1)}</div>
            <div style="margin-top:4px;color:#00ff88;">Pollard wins at k ‚âà ${Math.max(smooth.pMinus1Smooth || 10, smooth.qMinus1Smooth || 10)}</div>
        `;

        document.getElementById('hardExample').innerHTML = `
            <div>${hard.n} = ${hard.p} √ó ${hard.q}</div>
            <div style="margin-top:4px;">p-1 = ${hardP1}</div>
            <div>has prime factor ${hard.pMinus1Smooth || '>500'}</div>
            <div style="margin-top:2px;">q-1 = ${hardQ1}</div>
            <div>has prime factor ${hard.qMinus1Smooth || '>500'}</div>
            <div style="margin-top:4px;color:#ff6b6b;">Pollard needs k > ${Math.min(hard.pMinus1Smooth || 500, hard.qMinus1Smooth || 500)}</div>
        `;

        document.getElementById('smoothVsHardComparison').style.display = 'block';
        showToast('Smooth vs RSA comparison shown', 'info');
    });

    // Helper function to display factorization
    function factorizeDisplay(n) {
        if (n <= 1) return '1';
        const factors = [];
        let temp = n;
        for (let p = 2; p * p <= temp; p++) {
            let count = 0;
            while (temp % p === 0) { count++; temp /= p; }
            if (count > 0) factors.push(count > 1 ? `${p}^${count}` : `${p}`);
        }
        if (temp > 1) factors.push(temp);
        return factors.join(' √ó ');
    }

    function updateOrderHistory() {
        const history = explorer.orderGCD.history;
        if (history.length === 0) return;

        document.getElementById('orderHistory').style.display = 'block';
        let html = '';
        for (const h of history.slice(0, 10)) {
            if (h.success) {
                html += `<div style="color:#00ff88;padding:2px 0;border-bottom:1px solid #333;">‚úì ${h.n} = ${h.factor}√ó${h.otherFactor} (k=${h.foundAtK}, ${h.heuristic})</div>`;
            } else {
                html += `<div style="color:#ff6b6b;padding:2px 0;border-bottom:1px solid #333;">‚úó ${h.n} ‚Äî failed (${h.heuristic}, bound=${h.bound})</div>`;
            }
        }
        document.getElementById('orderHistoryContent').innerHTML = html;
    }
    </script>
</body>
</html>